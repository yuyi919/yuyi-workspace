/******************************************************************************
 * This file was generated by langium-cli 0.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, isAstNode } from 'langium';

export interface Action extends AstNode {
    readonly $container: Document;
    content: Array<Echo>
}

export const Action = 'Action';

export function isAction(item: unknown): item is Action {
    return reflection.isInstance(item, Action);
}

export interface AtInline extends AstNode {
    readonly $container: Echo;
    ref: Reference<Character>
}

export const AtInline = 'AtInline';

export function isAtInline(item: unknown): item is AtInline {
    return reflection.isInstance(item, AtInline);
}

export interface Call extends AstNode {
    readonly $container: Echo;
    args: Array<UseParam>
    pipe: Pipe
    ref: Reference<Macro>
}

export const Call = 'Call';

export function isCall(item: unknown): item is Call {
    return reflection.isInstance(item, Call);
}

export interface Character extends AstNode {
    readonly $container: CharactersDeclare;
    elements: Array<Param>
    modifiers: Array<Modifier>
    name: string
}

export const Character = 'Character';

export function isCharacter(item: unknown): item is Character {
    return reflection.isInstance(item, Character);
}

export interface Declare extends AstNode {
    readonly $container: Document;
}

export const Declare = 'Declare';

export function isDeclare(item: unknown): item is Declare {
    return reflection.isInstance(item, Declare);
}

export interface Dialog extends AstNode {
    readonly $container: Document;
    contents: Array<Echo>
    elements: Array<Reference<Modifier>>
    ref: Reference<Character>
}

export const Dialog = 'Dialog';

export function isDialog(item: unknown): item is Dialog {
    return reflection.isInstance(item, Dialog);
}

export interface Document extends AstNode {
    contents: Array<Dialog | Action>
    defines: Array<Declare>
}

export const Document = 'Document';

export function isDocument(item: unknown): item is Document {
    return reflection.isInstance(item, Document);
}

export interface Echo extends AstNode {
    readonly $container: Dialog | Action;
    pipe: Pipe
    text: Array<AtInline | Template | Call | Plain>
}

export const Echo = 'Echo';

export function isEcho(item: unknown): item is Echo {
    return reflection.isInstance(item, Echo);
}

export interface Expression extends AstNode {
    readonly $container: Template | Addition | Subtraction | Multiplication | Division | AssignExpression | Param | UseParam;
}

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export interface Identifier extends AstNode {
    readonly $container: MacroDeclare | Character | Macro;
    name: string
}

export const Identifier = 'Identifier';

export function isIdentifier(item: unknown): item is Identifier {
    return reflection.isInstance(item, Identifier);
}

export interface Modifier extends AstNode {
    readonly $container: Character;
    name: string
}

export const Modifier = 'Modifier';

export function isModifier(item: unknown): item is Modifier {
    return reflection.isInstance(item, Modifier);
}

export interface Pipe extends AstNode {
    readonly $container: Call | Echo;
    args: Array<UseParam>
    ref: Reference<Macro>
}

export const Pipe = 'Pipe';

export function isPipe(item: unknown): item is Pipe {
    return reflection.isInstance(item, Pipe);
}

export interface Plain extends AstNode {
    readonly $container: Echo;
    content: SafeText
}

export const Plain = 'Plain';

export function isPlain(item: unknown): item is Plain {
    return reflection.isInstance(item, Plain);
}

export interface PlainText extends AstNode {
    readonly $container: Param | UseParam;
    value: AnyPlainText
}

export const PlainText = 'PlainText';

export function isPlainText(item: unknown): item is PlainText {
    return reflection.isInstance(item, PlainText);
}

export interface QualifiedName extends AstNode {
    name: Array<Reference<Identifier>>
}

export const QualifiedName = 'QualifiedName';

export function isQualifiedName(item: unknown): item is QualifiedName {
    return reflection.isInstance(item, QualifiedName);
}

export interface Template extends AstNode {
    readonly $container: Echo;
    expression: Expression
}

export const Template = 'Template';

export function isTemplate(item: unknown): item is Template {
    return reflection.isInstance(item, Template);
}

export interface UseParam extends AstNode {
    readonly $container: Call | Pipe;
    ref: Reference<Param>
    value: LiteralExpression | PlainText
}

export const UseParam = 'UseParam';

export function isUseParam(item: unknown): item is UseParam {
    return reflection.isInstance(item, UseParam);
}

export interface CharactersDeclare extends Declare {
    elements: Array<Character>
    kind: 'Characters'
}

export const CharactersDeclare = 'CharactersDeclare';

export function isCharactersDeclare(item: unknown): item is CharactersDeclare {
    return reflection.isInstance(item, CharactersDeclare);
}

export interface MacroDeclare extends Declare {
    elements: Array<Macro>
    kind: 'Macros'
}

export const MacroDeclare = 'MacroDeclare';

export function isMacroDeclare(item: unknown): item is MacroDeclare {
    return reflection.isInstance(item, MacroDeclare);
}

export interface OtherDeclare extends Declare {
    elements: SafeText
    name: string
}

export const OtherDeclare = 'OtherDeclare';

export function isOtherDeclare(item: unknown): item is OtherDeclare {
    return reflection.isInstance(item, OtherDeclare);
}

export interface Addition extends Expression {
    left: Expression
    right: Expression
}

export const Addition = 'Addition';

export function isAddition(item: unknown): item is Addition {
    return reflection.isInstance(item, Addition);
}

export interface AssignExpression extends Expression {
    ref: Reference<Macro>
    right: Expression
}

export const AssignExpression = 'AssignExpression';

export function isAssignExpression(item: unknown): item is AssignExpression {
    return reflection.isInstance(item, AssignExpression);
}

export interface Division extends Expression {
    left: Expression
    right: Expression
}

export const Division = 'Division';

export function isDivision(item: unknown): item is Division {
    return reflection.isInstance(item, Division);
}

export interface LiteralExpression extends Expression {
    value: string | number | boolean
}

export const LiteralExpression = 'LiteralExpression';

export function isLiteralExpression(item: unknown): item is LiteralExpression {
    return reflection.isInstance(item, LiteralExpression);
}

export interface Multiplication extends Expression {
    left: Expression
    right: Expression
}

export const Multiplication = 'Multiplication';

export function isMultiplication(item: unknown): item is Multiplication {
    return reflection.isInstance(item, Multiplication);
}

export interface RefExpression extends Expression {
    ref: Reference<Macro>
}

export const RefExpression = 'RefExpression';

export function isRefExpression(item: unknown): item is RefExpression {
    return reflection.isInstance(item, RefExpression);
}

export interface Subtraction extends Expression {
    left: Expression
    right: Expression
}

export const Subtraction = 'Subtraction';

export function isSubtraction(item: unknown): item is Subtraction {
    return reflection.isInstance(item, Subtraction);
}

export interface Macro extends Identifier {
    args: Array<Param>
    groups: Array<Reference<Character>>
}

export const Macro = 'Macro';

export function isMacro(item: unknown): item is Macro {
    return reflection.isInstance(item, Macro);
}

export interface Param extends Identifier {
    value: LiteralExpression | PlainText
}

export const Param = 'Param';

export function isParam(item: unknown): item is Param {
    return reflection.isInstance(item, Param);
}

export type SafeText = string

export type SafeTextPiece = string

export type AnyPlainText = string

export type ESC_Markup = string

export type TOKEN_AT = string

export type Token_Equal = string

export type Token_Minus = string

export type Token_Colon = string

export type Token_PL = string

export type Token_PR = string

export type Token_P = string

export type WS = string

export type AdvscriptAstType = 'Action' | 'AtInline' | 'Call' | 'Character' | 'Declare' | 'Dialog' | 'Document' | 'Echo' | 'Expression' | 'Identifier' | 'Modifier' | 'Pipe' | 'Plain' | 'PlainText' | 'QualifiedName' | 'Template' | 'UseParam' | 'CharactersDeclare' | 'MacroDeclare' | 'OtherDeclare' | 'Addition' | 'AssignExpression' | 'Division' | 'LiteralExpression' | 'Multiplication' | 'RefExpression' | 'Subtraction' | 'Macro' | 'Param';

export type AdvscriptAstReference = 'AtInline:ref' | 'Call:ref' | 'Dialog:elements' | 'Dialog:ref' | 'Pipe:ref' | 'QualifiedName:name' | 'UseParam:ref' | 'AssignExpression:ref' | 'RefExpression:ref' | 'Macro:groups';

export class AdvscriptAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['Action', 'AtInline', 'Call', 'Character', 'Declare', 'Dialog', 'Document', 'Echo', 'Expression', 'Identifier', 'Modifier', 'Pipe', 'Plain', 'PlainText', 'QualifiedName', 'Template', 'UseParam', 'CharactersDeclare', 'MacroDeclare', 'OtherDeclare', 'Addition', 'AssignExpression', 'Division', 'LiteralExpression', 'Multiplication', 'RefExpression', 'Subtraction', 'Macro', 'Param'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case CharactersDeclare:
            case MacroDeclare:
            case OtherDeclare: {
                return this.isSubtype(Declare, supertype);
            }
            case Addition:
            case AssignExpression:
            case Division:
            case LiteralExpression:
            case Multiplication:
            case RefExpression:
            case Subtraction: {
                return this.isSubtype(Expression, supertype);
            }
            case Macro:
            case Param: {
                return this.isSubtype(Identifier, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(referenceId: AdvscriptAstReference): string {
        switch (referenceId) {
            case 'AtInline:ref': {
                return Character;
            }
            case 'Call:ref': {
                return Macro;
            }
            case 'Dialog:elements': {
                return Modifier;
            }
            case 'Dialog:ref': {
                return Character;
            }
            case 'Pipe:ref': {
                return Macro;
            }
            case 'QualifiedName:name': {
                return Identifier;
            }
            case 'UseParam:ref': {
                return Param;
            }
            case 'AssignExpression:ref': {
                return Macro;
            }
            case 'RefExpression:ref': {
                return Macro;
            }
            case 'Macro:groups': {
                return Character;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
}

export const reflection = new AdvscriptAstReflection();
