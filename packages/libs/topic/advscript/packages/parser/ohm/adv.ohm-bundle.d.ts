// AUTOGENERATED FILE
// This file was generated from adv.ohm by `ohm generateBundles`.

import {
  ActionDict,
  Grammar,
  IterationNode,
  Node,
  NonterminalNode,
  Semantics,
  TerminalNode
} from 'ohm-js';

export interface AdvScriptActionDict<T> extends ActionDict<T> {
  Scripts?: (this: NonterminalNode, arg0: IterationNode) => T;
  LogicBlock_IF?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode, arg6: NonterminalNode) => T;
  LogicBlock_WHILE?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: NonterminalNode) => T;
  LogicBlock_FOREACH?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: NonterminalNode) => T;
  LogicBlock_LET?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  LogicBlock_Story?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  LogicBlock?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Comment_notes?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Comment_single?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  Comment_multi?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  Comment?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  comment_single?: (this: NonterminalNode, arg0: IterationNode) => T;
  comment_note?: (this: NonterminalNode, arg0: IterationNode) => T;
  comment_multi?: (this: NonterminalNode, arg0: IterationNode) => T;
  comment_inline?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  StoryLine_templateText?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  StoryLine_plainText?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  StoryLine?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  raw?: (this: NonterminalNode, arg0: IterationNode) => T;
  story_line?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: IterationNode, arg3: TerminalNode) => T;
  expr_template?: (this: NonterminalNode, arg0: IterationNode) => T;
  expr_logic?: (this: NonterminalNode, arg0: IterationNode) => T;
  expr_quick?: (this: NonterminalNode, arg0: IterationNode) => T;
  expr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  plainLetter?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  chinese?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  template_quick?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: TerminalNode) => T;
  template_native?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  template?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Fountain_macro?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode, arg3: IterationNode) => T;
  Fountain_characterEscape?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Fountain_characterStatus?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Fountain?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  fountain_character?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode, arg2: IterationNode, arg3: IterationNode, arg4: NonterminalNode) => T;
  fountain_macro?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  fountain?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Fountain_callMacro?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  command?: (this: NonterminalNode, arg0: IterationNode) => T;
  callCommand?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  CallCommand?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  pipe_expr?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
  anwsome_a?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  anwsome_b?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  anwsome_c?: (this: NonterminalNode, arg0: IterationNode) => T;
  anwsome?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  logic_statment_let?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  logic_statment_empty?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode) => T;
  logic_statment?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  logic_exprs?: (this: NonterminalNode, arg0: IterationNode) => T;
  LET?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  AssignExpr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  LetAssignExpr_assign?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  LetAssignExpr_nonAssign?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  LetAssignExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  IF?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  END?: (this: NonterminalNode, arg0: TerminalNode) => T;
  ELSE?: (this: NonterminalNode, arg0: TerminalNode) => T;
  ELSEIF?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  WHILE?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  FOREACH?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  statment_end?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode | TerminalNode) => T;
  key?: (this: NonterminalNode, arg0: IterationNode) => T;
  identifier?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode) => T;
  expression?: (this: NonterminalNode, arg0: IterationNode) => T;
}

export interface AdvScriptSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: AdvScriptActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: AdvScriptActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: AdvScriptActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: AdvScriptActionDict<T>): this;
}

export interface AdvScriptGrammar extends Grammar {
  createSemantics(): AdvScriptSemantics;
  extendSemantics(superSemantics: AdvScriptSemantics): AdvScriptSemantics;
}

declare const grammar: AdvScriptGrammar;
export default grammar;

