// AUTOGENERATED FILE
// This file was generated from expression.ohm by `ohm generateBundles`.

import {
  ActionDict,
  Grammar,
  IterationNode,
  Node,
  NonterminalNode,
  Semantics,
  TerminalNode
} from 'ohm-js';

export interface AVSActionDict<T> extends ActionDict<T> {
  Main?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Process_Command?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: TerminalNode) => T;
  Process_Inline?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: IterationNode, arg3: TerminalNode) => T;
  Process_Pipe?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode) => T;
  Process?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PipeMacro?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  Command?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  Params_multiple?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: NonterminalNode) => T;
  Params_single?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Params?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Param_setValue?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Param_setFlag?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Param?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Expression_Assign?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Expression_Comma?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  Expression?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  key?: (this: NonterminalNode, arg0: IterationNode) => T;
  literal?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  Array?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  ArraySpread?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ArrayItems?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  CallExpression?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  string_doubleQuote?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  string_singleQuote?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  string?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  singleQuoteStringContent_nonEscaped?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  singleQuoteStringContent_escaped?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  singleQuoteStringContent?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  doubleQuoteStringContent_nonEscaped?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  doubleQuoteStringContent_escaped?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  doubleQuoteStringContent?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  singleEscapeCharacter?: (this: NonterminalNode, arg0: TerminalNode) => T;
  escapeCharacter?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  quote?: (this: NonterminalNode, arg0: TerminalNode) => T;
  boolean?: (this: NonterminalNode, arg0: TerminalNode) => T;
  number_sign?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  number_fract?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode, arg2: IterationNode) => T;
  number_hex?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
  number_whole?: (this: NonterminalNode, arg0: IterationNode) => T;
  number?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  hexdigit?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  percet?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode) => T;
  identifier?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode) => T;
  invalidIdentifier?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: IterationNode, arg3: NonterminalNode) => T;
  Exp_bool?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Exp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  JudgeExp_judge?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  JudgeExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AddExp_add?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  AddExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  MulExp_mul?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  MulExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ExpExp_power?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  ExpExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PriExp_paren?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  PriExp_pos?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  PriExp_neg?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  PriExp?: (this: NonterminalNode, arg0: NonterminalNode) => T;
}

export interface AVSSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: AVSActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: AVSActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: AVSActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: AVSActionDict<T>): this;
}

export interface AVSGrammar extends Grammar {
  createSemantics(): AVSSemantics;
  extendSemantics(superSemantics: AVSSemantics): AVSSemantics;
}

declare const grammar: AVSGrammar;
export default grammar;

