/******************************************************************************
 * This file was generated by langium-cli 0.3.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, isAstNode } from "langium";

export type Block = LogicBlock | StoryBlock | YamlBlock;

export const Block = "Block";

export function isBlock(item: unknown): item is Block {
  return reflection.isInstance(item, Block);
}

export type BOOLEAN = "false" | "true";

export type Call = AtInline | CallMacro | Label | Mark;

export const Call = "Call";

export function isCall(item: unknown): item is Call {
  return reflection.isInstance(item, Call);
}

export type CommonIndent = string;

export type Declare = CharactersDeclare | MacroDeclare | OtherDeclare;

export const Declare = "Declare";

export function isDeclare(item: unknown): item is Declare {
  return reflection.isInstance(item, Declare);
}

export type DeclareItem_Character = Character;

export const DeclareItem_Character = "DeclareItem_Character";

export function isDeclareItem_Character(item: unknown): item is DeclareItem_Character {
  return reflection.isInstance(item, DeclareItem_Character);
}

export type DeclareItem_Macro = Macro;

export const DeclareItem_Macro = "DeclareItem_Macro";

export function isDeclareItem_Macro(item: unknown): item is DeclareItem_Macro {
  return reflection.isInstance(item, DeclareItem_Macro);
}

export type DeclareKind = CharactersDeclareKind | KeyedDeclareKind | MacrosDeclareKind;

export const DeclareKind = "DeclareKind";

export function isDeclareKind(item: unknown): item is DeclareKind {
  return reflection.isInstance(item, DeclareKind);
}

export type DialogContent = Content;

export const DialogContent = "DialogContent";

export function isDialogContent(item: unknown): item is DialogContent {
  return reflection.isInstance(item, DialogContent);
}

export type Escapse = string;

export type Expression =
  | Addition
  | Assign
  | Comma
  | Conditional
  | LiteralExpression
  | Logical_And
  | Logical_Or
  | Multiplication
  | NullishCoalescing
  | Power
  | RefExpression
  | Relaction;

export const Expression = "Expression";

export function isExpression(item: unknown): item is Expression {
  return reflection.isInstance(item, Expression);
}

export type InitialExpression = Expression | TextExpression;

export const InitialExpression = "InitialExpression";

export function isInitialExpression(item: unknown): item is InitialExpression {
  return reflection.isInstance(item, InitialExpression);
}

export type LabelContent = string;

export type LiteralExpression = BooleanLiteral | NumberLiteral | StringLiteral;

export const LiteralExpression = "LiteralExpression";

export function isLiteralExpression(item: unknown): item is LiteralExpression {
  return reflection.isInstance(item, LiteralExpression);
}

export type LogicBlock = ConditionBlock;

export const LogicBlock = "LogicBlock";

export function isLogicBlock(item: unknown): item is LogicBlock {
  return reflection.isInstance(item, LogicBlock);
}

export type LogicStatment = VarStatement;

export const LogicStatment = "LogicStatment";

export function isLogicStatment(item: unknown): item is LogicStatment {
  return reflection.isInstance(item, LogicStatment);
}

export type Operator_Addition = string;

export type Operator_And = string;

export type Operator_Colon = string;

export type Operator_Division = string;

export type Operator_Equal = string;

export type Operator_EqualEqual = string;

export type Operator_LessThen = string;

export type Operator_LessThenEqual = string;

export type Operator_Minus = string;

export type Operator_MoreThen = string;

export type Operator_MoreThenEqual = string;

export type Operator_Multi = string;

export type Operator_Multiplication = string;

export type Operator_NullishCoalescing = string;

export type Operator_Or = string;

export type Operator_Plus = string;

export type Operator_Power = string;

export type Operator_Question = string;

export type Operator_Relaction = string;

export type Operator_Variable_Prefix = "$" | "%";

export type ParamInitialExpression = Expression | TextExpression;

export const ParamInitialExpression = "ParamInitialExpression";

export function isParamInitialExpression(item: unknown): item is ParamInitialExpression {
  return reflection.isInstance(item, ParamInitialExpression);
}

export type Pipe = MacroPipe | TextPipe;

export const Pipe = "Pipe";

export function isPipe(item: unknown): item is Pipe {
  return reflection.isInstance(item, Pipe);
}

export type PlainText = string;

export type PlainTextContnet = string;

export type RawText = string;

export type RawTextPiece = string;

export type Statment = LogicStatment;

export const Statment = "Statment";

export function isStatment(item: unknown): item is Statment {
  return reflection.isInstance(item, Statment);
}

export type StoryBlock = Action | Dialog;

export const StoryBlock = "StoryBlock";

export function isStoryBlock(item: unknown): item is StoryBlock {
  return reflection.isInstance(item, StoryBlock);
}

export type TextContnet = string;

export type VariableName = string;

export interface Action extends AstNode {
  readonly $container: DocumentContents;
  contents: Array<Content>;
}

export const Action = "Action";

export function isAction(item: unknown): item is Action {
  return reflection.isInstance(item, Action);
}

export interface Addition extends AstNode {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  left: Expression;
  operator: Operator_Addition;
  right: Expression;
}

export const Addition = "Addition";

export function isAddition(item: unknown): item is Addition {
  return reflection.isInstance(item, Addition);
}

export interface Assign extends AstNode {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  left: Expression;
  operator: Operator_Equal;
  right: Expression;
}

export const Assign = "Assign";

export function isAssign(item: unknown): item is Assign {
  return reflection.isInstance(item, Assign);
}

export interface AtInline extends AstNode {
  readonly $container: Content | Dialog | Label;
  ref: Reference<Character>;
}

export const AtInline = "AtInline";

export function isAtInline(item: unknown): item is AtInline {
  return reflection.isInstance(item, AtInline);
}

export interface BooleanLiteral extends AstNode {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  value: BOOLEAN;
}

export const BooleanLiteral = "BooleanLiteral";

export function isBooleanLiteral(item: unknown): item is BooleanLiteral {
  return reflection.isInstance(item, BooleanLiteral);
}

export interface CallMacro extends AstNode {
  readonly $container: Content | Dialog | Label;
  elements: Array<MacroParam>;
  pipe?: Pipe;
  ref: Reference<Macro>;
}

export const CallMacro = "CallMacro";

export function isCallMacro(item: unknown): item is CallMacro {
  return reflection.isInstance(item, CallMacro);
}

export interface Character extends AstNode {
  readonly $container: CharactersDeclare;
  elements: Array<Param>;
  modifiers?: ModifierList_Character;
  name: NameIdentifier;
}

export const Character = "Character";

export function isCharacter(item: unknown): item is Character {
  return reflection.isInstance(item, Character);
}

export interface CharacterRef extends AstNode {
  readonly $container: ModifierList_Macro;
  ref: Reference<Character>;
}

export const CharacterRef = "CharacterRef";

export function isCharacterRef(item: unknown): item is CharacterRef {
  return reflection.isInstance(item, CharacterRef);
}

export interface CharactersDeclare extends AstNode {
  readonly $container: TitlePage | YamlBlock;
  elements: Array<DeclareItem_Character>;
  name: CharactersDeclareKind;
}

export const CharactersDeclare = "CharactersDeclare";

export function isCharactersDeclare(item: unknown): item is CharactersDeclare {
  return reflection.isInstance(item, CharactersDeclare);
}

export interface CharactersDeclareKind extends AstNode {
  readonly $container: CharactersDeclare | MacroDeclare | OtherDeclare;
  text: "Characters";
}

export const CharactersDeclareKind = "CharactersDeclareKind";

export function isCharactersDeclareKind(item: unknown): item is CharactersDeclareKind {
  return reflection.isInstance(item, CharactersDeclareKind);
}

export interface Comma extends AstNode {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  left: Expression;
  right: Expression;
}

export const Comma = "Comma";

export function isComma(item: unknown): item is Comma {
  return reflection.isInstance(item, Comma);
}

export interface Conditional extends AstNode {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  condition: Expression;
  else: Expression;
  operator: Operator_Question;
  when: Expression;
}

export const Conditional = "Conditional";

export function isConditional(item: unknown): item is Conditional {
  return reflection.isInstance(item, Conditional);
}

export interface ConditionBlock extends AstNode {
  blocks: Array<LogicBlock_ELSE> | Array<LogicBlock_IF> | Array<LogicBlock_IFELSE>;
  end: EndStatement;
}

export const ConditionBlock = "ConditionBlock";

export function isConditionBlock(item: unknown): item is ConditionBlock {
  return reflection.isInstance(item, ConditionBlock);
}

export interface Content extends AstNode {
  readonly $container: Action | Dialog;
  content: Array<Call | Plain | Template>;
  indent?: CommonIndent;
  pipe?: Pipe;
}

export const Content = "Content";

export function isContent(item: unknown): item is Content {
  return reflection.isInstance(item, Content);
}

export interface Dialog extends AstNode {
  readonly $container: DocumentContents;
  contents: Array<DialogContent>;
  elements: Array<Call>;
  modifiers?: ModifierList_Dialog;
  ref: Reference<Character>;
}

export const Dialog = "Dialog";

export function isDialog(item: unknown): item is Dialog {
  return reflection.isInstance(item, Dialog);
}

export interface Document extends AstNode {
  content: DocumentContents;
  header: TitlePage;
}

export const Document = "Document";

export function isDocument(item: unknown): item is Document {
  return reflection.isInstance(item, Document);
}

export interface DocumentContents extends AstNode {
  readonly $container: Document | LogicBlock_ELSE | LogicBlock_IF | LogicBlock_IFELSE;
  contents: Array<Block | Statment>;
}

export const DocumentContents = "DocumentContents";

export function isDocumentContents(item: unknown): item is DocumentContents {
  return reflection.isInstance(item, DocumentContents);
}

export interface ElseIfStatement extends AstNode {
  readonly $container: LogicBlock_IFELSE;
  expression: Expression;
  kind: "|elseif";
}

export const ElseIfStatement = "ElseIfStatement";

export function isElseIfStatement(item: unknown): item is ElseIfStatement {
  return reflection.isInstance(item, ElseIfStatement);
}

export interface ElseStatement extends AstNode {
  readonly $container: LogicBlock_ELSE;
  kind: "|else";
}

export const ElseStatement = "ElseStatement";

export function isElseStatement(item: unknown): item is ElseStatement {
  return reflection.isInstance(item, ElseStatement);
}

export interface EndStatement extends AstNode {
  readonly $container: ConditionBlock;
  kind: "|end";
}

export const EndStatement = "EndStatement";

export function isEndStatement(item: unknown): item is EndStatement {
  return reflection.isInstance(item, EndStatement);
}

export interface Identifier extends AstNode {
  readonly $container: Macro | Param;
  text: string;
}

export const Identifier = "Identifier";

export function isIdentifier(item: unknown): item is Identifier {
  return reflection.isInstance(item, Identifier);
}

export interface IfStatement extends AstNode {
  readonly $container: LogicBlock_IF;
  expression: Expression;
  kind: "|if";
}

export const IfStatement = "IfStatement";

export function isIfStatement(item: unknown): item is IfStatement {
  return reflection.isInstance(item, IfStatement);
}

export interface KeyedDeclareKind extends AstNode {
  readonly $container: CharactersDeclare | MacroDeclare | OtherDeclare;
  text: string;
}

export const KeyedDeclareKind = "KeyedDeclareKind";

export function isKeyedDeclareKind(item: unknown): item is KeyedDeclareKind {
  return reflection.isInstance(item, KeyedDeclareKind);
}

export interface Label extends AstNode {
  readonly $container: Content | Dialog | Label;
  content: LabelContent;
  pipe: CallMacro | LabelContent | string;
}

export const Label = "Label";

export function isLabel(item: unknown): item is Label {
  return reflection.isInstance(item, Label);
}

export interface List extends AstNode {
  readonly $container: VarStatement;
  elements: Array<Variable>;
}

export const List = "List";

export function isList(item: unknown): item is List {
  return reflection.isInstance(item, List);
}

export interface Logical_And extends AstNode {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  left: Expression;
  operator: Operator_And;
  right: Expression;
}

export const Logical_And = "Logical_And";

export function isLogical_And(item: unknown): item is Logical_And {
  return reflection.isInstance(item, Logical_And);
}

export interface Logical_Or extends AstNode {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  left: Expression;
  operator: Operator_Or;
  right: Expression;
}

export const Logical_Or = "Logical_Or";

export function isLogical_Or(item: unknown): item is Logical_Or {
  return reflection.isInstance(item, Logical_Or);
}

export interface LogicBlock_ELSE extends AstNode {
  readonly $container: ConditionBlock;
  block: DocumentContents;
  condition: ElseStatement;
}

export const LogicBlock_ELSE = "LogicBlock_ELSE";

export function isLogicBlock_ELSE(item: unknown): item is LogicBlock_ELSE {
  return reflection.isInstance(item, LogicBlock_ELSE);
}

export interface LogicBlock_IF extends AstNode {
  readonly $container: ConditionBlock;
  block?: DocumentContents;
  condition: IfStatement;
}

export const LogicBlock_IF = "LogicBlock_IF";

export function isLogicBlock_IF(item: unknown): item is LogicBlock_IF {
  return reflection.isInstance(item, LogicBlock_IF);
}

export interface LogicBlock_IFELSE extends AstNode {
  readonly $container: ConditionBlock;
  block: DocumentContents;
  condition: ElseIfStatement;
}

export const LogicBlock_IFELSE = "LogicBlock_IFELSE";

export function isLogicBlock_IFELSE(item: unknown): item is LogicBlock_IFELSE {
  return reflection.isInstance(item, LogicBlock_IFELSE);
}

export interface Macro extends AstNode {
  readonly $container: MacroDeclare;
  elements: Array<Param>;
  modifiers?: ModifierList_Macro;
  name: Identifier;
}

export const Macro = "Macro";

export function isMacro(item: unknown): item is Macro {
  return reflection.isInstance(item, Macro);
}

export interface MacroDeclare extends AstNode {
  readonly $container: TitlePage | YamlBlock;
  elements: Array<DeclareItem_Macro>;
  name: MacrosDeclareKind;
}

export const MacroDeclare = "MacroDeclare";

export function isMacroDeclare(item: unknown): item is MacroDeclare {
  return reflection.isInstance(item, MacroDeclare);
}

export interface MacroParam extends AstNode {
  readonly $container: CallMacro | MacroPipe;
  ref: Reference<Param>;
  value?: InitialExpression;
}

export const MacroParam = "MacroParam";

export function isMacroParam(item: unknown): item is MacroParam {
  return reflection.isInstance(item, MacroParam);
}

export interface MacroPipe extends AstNode {
  readonly $container: CallMacro | Content | Template;
  elements: Array<MacroParam>;
  ref: Reference<Macro>;
}

export const MacroPipe = "MacroPipe";

export function isMacroPipe(item: unknown): item is MacroPipe {
  return reflection.isInstance(item, MacroPipe);
}

export interface MacrosDeclareKind extends AstNode {
  readonly $container: CharactersDeclare | MacroDeclare | OtherDeclare;
  text: "Macros";
}

export const MacrosDeclareKind = "MacrosDeclareKind";

export function isMacrosDeclareKind(item: unknown): item is MacrosDeclareKind {
  return reflection.isInstance(item, MacrosDeclareKind);
}

export interface Mark extends AstNode {
  readonly $container: Content | Dialog | Label;
  content: LabelContent;
}

export const Mark = "Mark";

export function isMark(item: unknown): item is Mark {
  return reflection.isInstance(item, Mark);
}

export interface Modifier extends AstNode {
  readonly $container: ModifierList_Character;
  name: NameIdentifier;
}

export const Modifier = "Modifier";

export function isModifier(item: unknown): item is Modifier {
  return reflection.isInstance(item, Modifier);
}

export interface ModifierList_Character extends AstNode {
  readonly $container: Character;
  elements: Array<Modifier>;
}

export const ModifierList_Character = "ModifierList_Character";

export function isModifierList_Character(item: unknown): item is ModifierList_Character {
  return reflection.isInstance(item, ModifierList_Character);
}

export interface ModifierList_Dialog extends AstNode {
  readonly $container: Dialog;
  elements: Array<ModifierRef>;
}

export const ModifierList_Dialog = "ModifierList_Dialog";

export function isModifierList_Dialog(item: unknown): item is ModifierList_Dialog {
  return reflection.isInstance(item, ModifierList_Dialog);
}

export interface ModifierList_Macro extends AstNode {
  readonly $container: Macro;
  elements: Array<CharacterRef>;
}

export const ModifierList_Macro = "ModifierList_Macro";

export function isModifierList_Macro(item: unknown): item is ModifierList_Macro {
  return reflection.isInstance(item, ModifierList_Macro);
}

export interface ModifierRef extends AstNode {
  readonly $container: ModifierList_Dialog;
  ref: Reference<Modifier>;
}

export const ModifierRef = "ModifierRef";

export function isModifierRef(item: unknown): item is ModifierRef {
  return reflection.isInstance(item, ModifierRef);
}

export interface Multiplication extends AstNode {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  left: Expression;
  operator: Operator_Multi;
  right: Expression;
}

export const Multiplication = "Multiplication";

export function isMultiplication(item: unknown): item is Multiplication {
  return reflection.isInstance(item, Multiplication);
}

export interface NameIdentifier extends AstNode {
  readonly $container: Character | Modifier;
  text: string;
}

export const NameIdentifier = "NameIdentifier";

export function isNameIdentifier(item: unknown): item is NameIdentifier {
  return reflection.isInstance(item, NameIdentifier);
}

export interface NullishCoalescing extends AstNode {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  left: Expression;
  operator: Operator_NullishCoalescing;
  right: Expression;
}

export const NullishCoalescing = "NullishCoalescing";

export function isNullishCoalescing(item: unknown): item is NullishCoalescing {
  return reflection.isInstance(item, NullishCoalescing);
}

export interface NumberLiteral extends AstNode {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  value: number;
}

export const NumberLiteral = "NumberLiteral";

export function isNumberLiteral(item: unknown): item is NumberLiteral {
  return reflection.isInstance(item, NumberLiteral);
}

export interface OtherDeclare extends AstNode {
  readonly $container: TitlePage | YamlBlock;
  elements?: PlainTextExpression;
  name: KeyedDeclareKind;
}

export const OtherDeclare = "OtherDeclare";

export function isOtherDeclare(item: unknown): item is OtherDeclare {
  return reflection.isInstance(item, OtherDeclare);
}

export interface Param extends AstNode {
  readonly $container: Character | Macro;
  name: Identifier;
  value?: ParamInitialExpression;
}

export const Param = "Param";

export function isParam(item: unknown): item is Param {
  return reflection.isInstance(item, Param);
}

export interface PercentLiteral extends NumberLiteral {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  percent: boolean;
  value: number;
}

export const PercentLiteral = "PercentLiteral";

export function isPercentLiteral(item: unknown): item is PercentLiteral {
  return reflection.isInstance(item, PercentLiteral);
}

export interface Plain extends AstNode {
  readonly $container: Content;
  content: PlainText;
}

export const Plain = "Plain";

export function isPlain(item: unknown): item is Plain {
  return reflection.isInstance(item, Plain);
}

export interface PlainTextExpression extends AstNode {
  readonly $container: OtherDeclare;
  value: PlainTextContnet;
}

export const PlainTextExpression = "PlainTextExpression";

export function isPlainTextExpression(item: unknown): item is PlainTextExpression {
  return reflection.isInstance(item, PlainTextExpression);
}

export interface Power extends AstNode {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  left: Expression;
  operator: Operator_Power;
  right: Expression;
}

export const Power = "Power";

export function isPower(item: unknown): item is Power {
  return reflection.isInstance(item, Power);
}

export interface RefExpression extends AstNode {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  ref: Reference<Variable>;
}

export const RefExpression = "RefExpression";

export function isRefExpression(item: unknown): item is RefExpression {
  return reflection.isInstance(item, RefExpression);
}

export interface Relaction extends AstNode {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  left: Expression;
  operator: Operator_Relaction;
  right: Expression;
}

export const Relaction = "Relaction";

export function isRelaction(item: unknown): item is Relaction {
  return reflection.isInstance(item, Relaction);
}

export interface StringLiteral extends AstNode {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  value: string;
}

export const StringLiteral = "StringLiteral";

export function isStringLiteral(item: unknown): item is StringLiteral {
  return reflection.isInstance(item, StringLiteral);
}

export interface Template extends AstNode {
  readonly $container: Content;
  expression?: Expression;
  pipe?: Pipe;
}

export const Template = "Template";

export function isTemplate(item: unknown): item is Template {
  return reflection.isInstance(item, Template);
}

export interface TextExpression extends AstNode {
  readonly $container:
    | Addition
    | Assign
    | Comma
    | Conditional
    | ElseIfStatement
    | IfStatement
    | Logical_And
    | Logical_Or
    | MacroParam
    | Multiplication
    | NullishCoalescing
    | Param
    | Power
    | Relaction
    | Template
    | Variable;
  value: TextContnet;
}

export const TextExpression = "TextExpression";

export function isTextExpression(item: unknown): item is TextExpression {
  return reflection.isInstance(item, TextExpression);
}

export interface TextPipe extends AstNode {
  readonly $container: CallMacro | Content | Template;
  text: LabelContent;
}

export const TextPipe = "TextPipe";

export function isTextPipe(item: unknown): item is TextPipe {
  return reflection.isInstance(item, TextPipe);
}

export interface TitlePage extends AstNode {
  readonly $container: Document;
  defines: Array<Declare>;
}

export const TitlePage = "TitlePage";

export function isTitlePage(item: unknown): item is TitlePage {
  return reflection.isInstance(item, TitlePage);
}

export interface Variable extends AstNode {
  readonly $container: List;
  initial?: Expression;
  name: VariableIdentifier;
}

export const Variable = "Variable";

export function isVariable(item: unknown): item is Variable {
  return reflection.isInstance(item, Variable);
}

export interface VariableIdentifier extends AstNode {
  readonly $container: Variable;
  prefix?: Operator_Variable_Prefix;
  text: string;
}

export const VariableIdentifier = "VariableIdentifier";

export function isVariableIdentifier(item: unknown): item is VariableIdentifier {
  return reflection.isInstance(item, VariableIdentifier);
}

export interface VarStatement extends AstNode {
  readonly $container: DocumentContents;
  datas: List;
  kind: "|let";
}

export const VarStatement = "VarStatement";

export function isVarStatement(item: unknown): item is VarStatement {
  return reflection.isInstance(item, VarStatement);
}

export interface YamlBlock extends AstNode {
  readonly $container: DocumentContents;
  defines: Array<Declare>;
}

export const YamlBlock = "YamlBlock";

export function isYamlBlock(item: unknown): item is YamlBlock {
  return reflection.isInstance(item, YamlBlock);
}

export type AdvScriptAstType =
  | "Action"
  | "Addition"
  | "Assign"
  | "AtInline"
  | "Block"
  | "BooleanLiteral"
  | "Call"
  | "CallMacro"
  | "Character"
  | "CharacterRef"
  | "CharactersDeclare"
  | "CharactersDeclareKind"
  | "Comma"
  | "ConditionBlock"
  | "Conditional"
  | "Content"
  | "Declare"
  | "DeclareItem_Character"
  | "DeclareItem_Macro"
  | "DeclareKind"
  | "Dialog"
  | "DialogContent"
  | "Document"
  | "DocumentContents"
  | "ElseIfStatement"
  | "ElseStatement"
  | "EndStatement"
  | "Expression"
  | "Identifier"
  | "IfStatement"
  | "InitialExpression"
  | "KeyedDeclareKind"
  | "Label"
  | "List"
  | "LiteralExpression"
  | "LogicBlock"
  | "LogicBlock_ELSE"
  | "LogicBlock_IF"
  | "LogicBlock_IFELSE"
  | "LogicStatment"
  | "Logical_And"
  | "Logical_Or"
  | "Macro"
  | "MacroDeclare"
  | "MacroParam"
  | "MacroPipe"
  | "MacrosDeclareKind"
  | "Mark"
  | "Modifier"
  | "ModifierList_Character"
  | "ModifierList_Dialog"
  | "ModifierList_Macro"
  | "ModifierRef"
  | "Multiplication"
  | "NameIdentifier"
  | "NullishCoalescing"
  | "NumberLiteral"
  | "OtherDeclare"
  | "Param"
  | "ParamInitialExpression"
  | "PercentLiteral"
  | "Pipe"
  | "Plain"
  | "PlainTextExpression"
  | "Power"
  | "RefExpression"
  | "Relaction"
  | "Statment"
  | "StoryBlock"
  | "StringLiteral"
  | "Template"
  | "TextExpression"
  | "TextPipe"
  | "TitlePage"
  | "VarStatement"
  | "Variable"
  | "VariableIdentifier"
  | "YamlBlock";

export type AdvScriptAstReference =
  | "AtInline:ref"
  | "CallMacro:ref"
  | "CharacterRef:ref"
  | "Dialog:ref"
  | "MacroParam:ref"
  | "MacroPipe:ref"
  | "ModifierRef:ref"
  | "RefExpression:ref";

export class AdvScriptAstReflection implements AstReflection {
  getAllTypes(): string[] {
    return [
      "Action",
      "Addition",
      "Assign",
      "AtInline",
      "Block",
      "BooleanLiteral",
      "Call",
      "CallMacro",
      "Character",
      "CharacterRef",
      "CharactersDeclare",
      "CharactersDeclareKind",
      "Comma",
      "ConditionBlock",
      "Conditional",
      "Content",
      "Declare",
      "DeclareItem_Character",
      "DeclareItem_Macro",
      "DeclareKind",
      "Dialog",
      "DialogContent",
      "Document",
      "DocumentContents",
      "ElseIfStatement",
      "ElseStatement",
      "EndStatement",
      "Expression",
      "Identifier",
      "IfStatement",
      "InitialExpression",
      "KeyedDeclareKind",
      "Label",
      "List",
      "LiteralExpression",
      "LogicBlock",
      "LogicBlock_ELSE",
      "LogicBlock_IF",
      "LogicBlock_IFELSE",
      "LogicStatment",
      "Logical_And",
      "Logical_Or",
      "Macro",
      "MacroDeclare",
      "MacroParam",
      "MacroPipe",
      "MacrosDeclareKind",
      "Mark",
      "Modifier",
      "ModifierList_Character",
      "ModifierList_Dialog",
      "ModifierList_Macro",
      "ModifierRef",
      "Multiplication",
      "NameIdentifier",
      "NullishCoalescing",
      "NumberLiteral",
      "OtherDeclare",
      "Param",
      "ParamInitialExpression",
      "PercentLiteral",
      "Pipe",
      "Plain",
      "PlainTextExpression",
      "Power",
      "RefExpression",
      "Relaction",
      "Statment",
      "StoryBlock",
      "StringLiteral",
      "Template",
      "TextExpression",
      "TextPipe",
      "TitlePage",
      "VarStatement",
      "Variable",
      "VariableIdentifier",
      "YamlBlock"
    ];
  }

  isInstance(node: unknown, type: string): boolean {
    return isAstNode(node) && this.isSubtype(node.$type, type);
  }

  isSubtype(subtype: string, supertype: string): boolean {
    if (subtype === supertype) {
      return true;
    }
    switch (subtype) {
      case Action:
      case Dialog: {
        return this.isSubtype(StoryBlock, supertype);
      }
      case Addition:
      case Assign:
      case Comma:
      case Conditional:
      case Logical_And:
      case Logical_Or:
      case Multiplication:
      case NullishCoalescing:
      case Power:
      case RefExpression:
      case Relaction:
      case LiteralExpression: {
        return this.isSubtype(Expression, supertype);
      }
      case AtInline:
      case CallMacro:
      case Label:
      case Mark: {
        return this.isSubtype(Call, supertype);
      }
      case BooleanLiteral:
      case NumberLiteral:
      case StringLiteral: {
        return this.isSubtype(LiteralExpression, supertype);
      }
      case Character: {
        return this.isSubtype(DeclareItem_Character, supertype);
      }
      case CharactersDeclare:
      case MacroDeclare:
      case OtherDeclare: {
        return this.isSubtype(Declare, supertype);
      }
      case CharactersDeclareKind:
      case KeyedDeclareKind:
      case MacrosDeclareKind: {
        return this.isSubtype(DeclareKind, supertype);
      }
      case ConditionBlock: {
        return this.isSubtype(LogicBlock, supertype);
      }
      case Content: {
        return this.isSubtype(DialogContent, supertype);
      }
      case Macro: {
        return this.isSubtype(DeclareItem_Macro, supertype);
      }
      case MacroPipe:
      case TextPipe: {
        return this.isSubtype(Pipe, supertype);
      }
      case PercentLiteral: {
        return this.isSubtype(NumberLiteral, supertype);
      }
      case TextExpression:
      case Expression: {
        return (
          this.isSubtype(ParamInitialExpression, supertype) ||
          this.isSubtype(InitialExpression, supertype)
        );
      }
      case VarStatement: {
        return this.isSubtype(LogicStatment, supertype);
      }
      case YamlBlock:
      case StoryBlock: {
        return this.isSubtype(Block, supertype);
      }
      case LogicStatment: {
        return this.isSubtype(Statment, supertype);
      }
      default: {
        return false;
      }
    }
  }

  getReferenceType(referenceId: AdvScriptAstReference): string {
    switch (referenceId) {
      case "AtInline:ref": {
        return Character;
      }
      case "CallMacro:ref": {
        return Macro;
      }
      case "CharacterRef:ref": {
        return Character;
      }
      case "Dialog:ref": {
        return Character;
      }
      case "MacroParam:ref": {
        return Param;
      }
      case "MacroPipe:ref": {
        return Macro;
      }
      case "ModifierRef:ref": {
        return Modifier;
      }
      case "RefExpression:ref": {
        return Variable;
      }
      default: {
        throw new Error(`${referenceId} is not a valid reference id.`);
      }
    }
  }
}

export const reflection = new AdvScriptAstReflection();
