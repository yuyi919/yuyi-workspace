/******************************************************************************
 * This file was generated by langium-cli 0.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, isAstNode } from 'langium';

export interface Block extends AstNode {
    readonly $container: DocumentContents;
    defines: Array<Declare>
}

export const Block = 'Block';

export function isBlock(item: unknown): item is Block {
    return reflection.isInstance(item, Block);
}

export interface Call extends AstNode {
    readonly $container: Dialog | DialogContent | Label;
}

export const Call = 'Call';

export function isCall(item: unknown): item is Call {
    return reflection.isInstance(item, Call);
}

export interface CharacterRef extends AstNode {
    readonly $container: ModifierList_Macro;
    ref: Reference<Character>
}

export const CharacterRef = 'CharacterRef';

export function isCharacterRef(item: unknown): item is CharacterRef {
    return reflection.isInstance(item, CharacterRef);
}

export interface ConditionBlock extends AstNode {
    blocks: Array<LogicBlock_IF | LogicBlock_IFELSE | LogicBlock_ELSE>
}

export const ConditionBlock = 'ConditionBlock';

export function isConditionBlock(item: unknown): item is ConditionBlock {
    return reflection.isInstance(item, ConditionBlock);
}

export interface Declare extends AstNode {
    readonly $container: TitlePage | Block;
}

export const Declare = 'Declare';

export function isDeclare(item: unknown): item is Declare {
    return reflection.isInstance(item, Declare);
}

export interface DeclareItem_Character extends AstNode {
    readonly $container: CharactersDeclare;
    elements: Array<Param>
    modifiers: ModifierList_Character
    name: NameIdentifier
}

export const DeclareItem_Character = 'DeclareItem_Character';

export function isDeclareItem_Character(item: unknown): item is DeclareItem_Character {
    return reflection.isInstance(item, DeclareItem_Character);
}

export interface DeclareItem_Macro extends AstNode {
    readonly $container: MacroDeclare;
    elements: Array<Param>
    modifiers: ModifierList_Macro
    name: Identifier
}

export const DeclareItem_Macro = 'DeclareItem_Macro';

export function isDeclareItem_Macro(item: unknown): item is DeclareItem_Macro {
    return reflection.isInstance(item, DeclareItem_Macro);
}

export interface DeclareKind extends AstNode {
    readonly $container: CharactersDeclare | MacroDeclare | OtherDeclare;
}

export const DeclareKind = 'DeclareKind';

export function isDeclareKind(item: unknown): item is DeclareKind {
    return reflection.isInstance(item, DeclareKind);
}

export interface DialogContent extends AstNode {
    readonly $container: Action | Dialog;
    content: Array<Template | Call | ESCToken | Plain>
    indent: CommonIndent
    pipe: Pipe
}

export const DialogContent = 'DialogContent';

export function isDialogContent(item: unknown): item is DialogContent {
    return reflection.isInstance(item, DialogContent);
}

export interface Document extends AstNode {
    content: DocumentContents
    header: TitlePage
}

export const Document = 'Document';

export function isDocument(item: unknown): item is Document {
    return reflection.isInstance(item, Document);
}

export interface DocumentContents extends AstNode {
    readonly $container: Document | LogicBlock_IF | LogicBlock_IFELSE | LogicBlock_ELSE;
    contents: Array<Block | Statment>
}

export const DocumentContents = 'DocumentContents';

export function isDocumentContents(item: unknown): item is DocumentContents {
    return reflection.isInstance(item, DocumentContents);
}

export interface ElseIfStatement extends AstNode {
    readonly $container: LogicBlock_IFELSE;
    expression: Expression
    kind: '|elseif'
}

export const ElseIfStatement = 'ElseIfStatement';

export function isElseIfStatement(item: unknown): item is ElseIfStatement {
    return reflection.isInstance(item, ElseIfStatement);
}

export interface ElseStatement extends AstNode {
    readonly $container: LogicBlock_ELSE;
    kind: '|else'
}

export const ElseStatement = 'ElseStatement';

export function isElseStatement(item: unknown): item is ElseStatement {
    return reflection.isInstance(item, ElseStatement);
}

export interface EndStatement extends AstNode {
    kind: '|end'
}

export const EndStatement = 'EndStatement';

export function isEndStatement(item: unknown): item is EndStatement {
    return reflection.isInstance(item, EndStatement);
}

export interface ESCToken extends AstNode {
    readonly $container: DialogContent;
    content: Token_Bracket_L | Token_Bracket_R | Token_Template_L | Token_Template_R
}

export const ESCToken = 'ESCToken';

export function isESCToken(item: unknown): item is ESCToken {
    return reflection.isInstance(item, ESCToken);
}

export interface Identifier extends AstNode {
    readonly $container: Param | DeclareItem_Macro;
    text: string
}

export const Identifier = 'Identifier';

export function isIdentifier(item: unknown): item is Identifier {
    return reflection.isInstance(item, Identifier);
}

export interface IfStatement extends AstNode {
    readonly $container: LogicBlock_IF;
    expression: Expression
    kind: '|if'
}

export const IfStatement = 'IfStatement';

export function isIfStatement(item: unknown): item is IfStatement {
    return reflection.isInstance(item, IfStatement);
}

export interface InitialExpression extends AstNode {
    readonly $container: Param | MacroParam;
}

export const InitialExpression = 'InitialExpression';

export function isInitialExpression(item: unknown): item is InitialExpression {
    return reflection.isInstance(item, InitialExpression);
}

export interface List extends AstNode {
    readonly $container: LogicStatment;
    elements: Array<Variable>
}

export const List = 'List';

export function isList(item: unknown): item is List {
    return reflection.isInstance(item, List);
}

export interface LogicBlock_ELSE extends AstNode {
    readonly $container: ConditionBlock;
    block: DocumentContents
    condition: ElseStatement
}

export const LogicBlock_ELSE = 'LogicBlock_ELSE';

export function isLogicBlock_ELSE(item: unknown): item is LogicBlock_ELSE {
    return reflection.isInstance(item, LogicBlock_ELSE);
}

export interface LogicBlock_IF extends AstNode {
    readonly $container: ConditionBlock;
    block: DocumentContents
    condition: IfStatement
}

export const LogicBlock_IF = 'LogicBlock_IF';

export function isLogicBlock_IF(item: unknown): item is LogicBlock_IF {
    return reflection.isInstance(item, LogicBlock_IF);
}

export interface LogicBlock_IFELSE extends AstNode {
    readonly $container: ConditionBlock;
    block: DocumentContents
    condition: ElseIfStatement
}

export const LogicBlock_IFELSE = 'LogicBlock_IFELSE';

export function isLogicBlock_IFELSE(item: unknown): item is LogicBlock_IFELSE {
    return reflection.isInstance(item, LogicBlock_IFELSE);
}

export interface LogicStatment extends AstNode {
    datas: List
    kind: '|let'
}

export const LogicStatment = 'LogicStatment';

export function isLogicStatment(item: unknown): item is LogicStatment {
    return reflection.isInstance(item, LogicStatment);
}

export interface MacroParam extends AstNode {
    readonly $container: CallMacro | MacroPipe;
    ref: Reference<Param>
    value: InitialExpression
}

export const MacroParam = 'MacroParam';

export function isMacroParam(item: unknown): item is MacroParam {
    return reflection.isInstance(item, MacroParam);
}

export interface Modifier extends AstNode {
    readonly $container: ModifierList_Character;
    name: NameIdentifier
}

export const Modifier = 'Modifier';

export function isModifier(item: unknown): item is Modifier {
    return reflection.isInstance(item, Modifier);
}

export interface ModifierList_Character extends AstNode {
    readonly $container: DeclareItem_Character;
    elements: Array<Modifier>
}

export const ModifierList_Character = 'ModifierList_Character';

export function isModifierList_Character(item: unknown): item is ModifierList_Character {
    return reflection.isInstance(item, ModifierList_Character);
}

export interface ModifierList_Dialog extends AstNode {
    readonly $container: Dialog;
    elements: Array<ModifierRef>
}

export const ModifierList_Dialog = 'ModifierList_Dialog';

export function isModifierList_Dialog(item: unknown): item is ModifierList_Dialog {
    return reflection.isInstance(item, ModifierList_Dialog);
}

export interface ModifierList_Macro extends AstNode {
    readonly $container: DeclareItem_Macro;
    elements: Array<CharacterRef>
}

export const ModifierList_Macro = 'ModifierList_Macro';

export function isModifierList_Macro(item: unknown): item is ModifierList_Macro {
    return reflection.isInstance(item, ModifierList_Macro);
}

export interface ModifierRef extends AstNode {
    readonly $container: ModifierList_Dialog;
    ref: Reference<Modifier>
}

export const ModifierRef = 'ModifierRef';

export function isModifierRef(item: unknown): item is ModifierRef {
    return reflection.isInstance(item, ModifierRef);
}

export interface NameIdentifier extends AstNode {
    readonly $container: Modifier | DeclareItem_Character;
    text: string
}

export const NameIdentifier = 'NameIdentifier';

export function isNameIdentifier(item: unknown): item is NameIdentifier {
    return reflection.isInstance(item, NameIdentifier);
}

export interface Param extends AstNode {
    readonly $container: DeclareItem_Character | DeclareItem_Macro;
    name: Identifier
    value: ParamInitialExpression
}

export const Param = 'Param';

export function isParam(item: unknown): item is Param {
    return reflection.isInstance(item, Param);
}

export interface ParamInitialExpression extends AstNode {
    readonly $container: Param | MacroParam;
    value: TextContnet
}

export const ParamInitialExpression = 'ParamInitialExpression';

export function isParamInitialExpression(item: unknown): item is ParamInitialExpression {
    return reflection.isInstance(item, ParamInitialExpression);
}

export interface Pipe extends AstNode {
    readonly $container: CallMacro | Template | DialogContent;
}

export const Pipe = 'Pipe';

export function isPipe(item: unknown): item is Pipe {
    return reflection.isInstance(item, Pipe);
}

export interface Plain extends AstNode {
    readonly $container: DialogContent;
    content: PlainText
}

export const Plain = 'Plain';

export function isPlain(item: unknown): item is Plain {
    return reflection.isInstance(item, Plain);
}

export interface PlainTextExpression extends AstNode {
    readonly $container: OtherDeclare;
    value: PlainTextContnet
}

export const PlainTextExpression = 'PlainTextExpression';

export function isPlainTextExpression(item: unknown): item is PlainTextExpression {
    return reflection.isInstance(item, PlainTextExpression);
}

export interface QualifiedName extends AstNode {
    name: Array<Reference<Identifier>>
}

export const QualifiedName = 'QualifiedName';

export function isQualifiedName(item: unknown): item is QualifiedName {
    return reflection.isInstance(item, QualifiedName);
}

export interface Statment extends AstNode {
    readonly $container: DocumentContents;
}

export const Statment = 'Statment';

export function isStatment(item: unknown): item is Statment {
    return reflection.isInstance(item, Statment);
}

export interface StoryBlock extends AstNode {
}

export const StoryBlock = 'StoryBlock';

export function isStoryBlock(item: unknown): item is StoryBlock {
    return reflection.isInstance(item, StoryBlock);
}

export interface Template extends AstNode {
    readonly $container: DialogContent;
    expression: Expression
    pipe: Pipe
}

export const Template = 'Template';

export function isTemplate(item: unknown): item is Template {
    return reflection.isInstance(item, Template);
}

export interface TitlePage extends AstNode {
    readonly $container: Document;
    defines: Array<Declare>
}

export const TitlePage = 'TitlePage';

export function isTitlePage(item: unknown): item is TitlePage {
    return reflection.isInstance(item, TitlePage);
}

export interface TopExpression extends AstNode {
    readonly $container: IfStatement | ElseIfStatement | Template | Comma | Conditional | NullishCoalescing | Logical_Or | Logical_And | Relaction | Addition | Multiplication | Power | Assign | Variable;
}

export const TopExpression = 'TopExpression';

export function isTopExpression(item: unknown): item is TopExpression {
    return reflection.isInstance(item, TopExpression);
}

export interface Variable extends AstNode {
    readonly $container: List;
    initial: TopExpression
    name: VariableIdentifier
}

export const Variable = 'Variable';

export function isVariable(item: unknown): item is Variable {
    return reflection.isInstance(item, Variable);
}

export interface VariableIdentifier extends AstNode {
    readonly $container: Variable;
    prefix: Operator_Variable_Prefix
    text: string
}

export const VariableIdentifier = 'VariableIdentifier';

export function isVariableIdentifier(item: unknown): item is VariableIdentifier {
    return reflection.isInstance(item, VariableIdentifier);
}

export interface YamlBlock extends Block {
}

export const YamlBlock = 'YamlBlock';

export function isYamlBlock(item: unknown): item is YamlBlock {
    return reflection.isInstance(item, YamlBlock);
}

export interface AtInline extends Call {
    ref: Reference<Character>
}

export const AtInline = 'AtInline';

export function isAtInline(item: unknown): item is AtInline {
    return reflection.isInstance(item, AtInline);
}

export interface CallMacro extends Call {
    elements: Array<MacroParam>
    pipe: Pipe
    ref: Reference<Macro>
}

export const CallMacro = 'CallMacro';

export function isCallMacro(item: unknown): item is CallMacro {
    return reflection.isInstance(item, CallMacro);
}

export interface Label extends Call {
    content: LabelContent
    pipe: string | CallMacro | LabelContent
}

export const Label = 'Label';

export function isLabel(item: unknown): item is Label {
    return reflection.isInstance(item, Label);
}

export interface Mark extends Call {
    content: LabelContent
}

export const Mark = 'Mark';

export function isMark(item: unknown): item is Mark {
    return reflection.isInstance(item, Mark);
}

export interface CharactersDeclare extends Declare {
    elements: Array<DeclareItem_Character>
    name: CharactersDeclareKind
}

export const CharactersDeclare = 'CharactersDeclare';

export function isCharactersDeclare(item: unknown): item is CharactersDeclare {
    return reflection.isInstance(item, CharactersDeclare);
}

export interface MacroDeclare extends Declare {
    elements: Array<DeclareItem_Macro>
    name: MacrosDeclareKind
}

export const MacroDeclare = 'MacroDeclare';

export function isMacroDeclare(item: unknown): item is MacroDeclare {
    return reflection.isInstance(item, MacroDeclare);
}

export interface OtherDeclare extends Declare {
    elements: PlainTextExpression
    name: KeyedDeclareKind
}

export const OtherDeclare = 'OtherDeclare';

export function isOtherDeclare(item: unknown): item is OtherDeclare {
    return reflection.isInstance(item, OtherDeclare);
}

export interface Character extends DeclareItem_Character {
}

export const Character = 'Character';

export function isCharacter(item: unknown): item is Character {
    return reflection.isInstance(item, Character);
}

export interface Macro extends DeclareItem_Macro {
}

export const Macro = 'Macro';

export function isMacro(item: unknown): item is Macro {
    return reflection.isInstance(item, Macro);
}

export interface CharactersDeclareKind extends DeclareKind {
    text: 'Characters'
}

export const CharactersDeclareKind = 'CharactersDeclareKind';

export function isCharactersDeclareKind(item: unknown): item is CharactersDeclareKind {
    return reflection.isInstance(item, CharactersDeclareKind);
}

export interface KeyedDeclareKind extends DeclareKind {
    text: string
}

export const KeyedDeclareKind = 'KeyedDeclareKind';

export function isKeyedDeclareKind(item: unknown): item is KeyedDeclareKind {
    return reflection.isInstance(item, KeyedDeclareKind);
}

export interface MacrosDeclareKind extends DeclareKind {
    text: 'Macros'
}

export const MacrosDeclareKind = 'MacrosDeclareKind';

export function isMacrosDeclareKind(item: unknown): item is MacrosDeclareKind {
    return reflection.isInstance(item, MacrosDeclareKind);
}

export interface Content extends DialogContent {
}

export const Content = 'Content';

export function isContent(item: unknown): item is Content {
    return reflection.isInstance(item, Content);
}

export interface TextExpression extends ParamInitialExpression, InitialExpression {
}

export const TextExpression = 'TextExpression';

export function isTextExpression(item: unknown): item is TextExpression {
    return reflection.isInstance(item, TextExpression);
}

export interface VarStatement extends LogicStatment {
}

export const VarStatement = 'VarStatement';

export function isVarStatement(item: unknown): item is VarStatement {
    return reflection.isInstance(item, VarStatement);
}

export interface MacroPipe extends Pipe {
    elements: Array<MacroParam>
    ref?: Reference<Macro>
}

export const MacroPipe = 'MacroPipe';

export function isMacroPipe(item: unknown): item is MacroPipe {
    return reflection.isInstance(item, MacroPipe);
}

export interface TextPipe extends Pipe {
    text: LabelContent
}

export const TextPipe = 'TextPipe';

export function isTextPipe(item: unknown): item is TextPipe {
    return reflection.isInstance(item, TextPipe);
}

export interface Action extends StoryBlock {
    contents: Array<Content>
}

export const Action = 'Action';

export function isAction(item: unknown): item is Action {
    return reflection.isInstance(item, Action);
}

export interface Dialog extends StoryBlock {
    contents: Array<DialogContent>
    elements: Array<Call>
    modifiers: ModifierList_Dialog
    ref: Reference<Character>
}

export const Dialog = 'Dialog';

export function isDialog(item: unknown): item is Dialog {
    return reflection.isInstance(item, Dialog);
}

export interface Expression extends TopExpression {
}

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export interface Addition extends Expression {
    left: Expression
    operator: Operator_Addition
    right: Expression
}

export const Addition = 'Addition';

export function isAddition(item: unknown): item is Addition {
    return reflection.isInstance(item, Addition);
}

export interface Assign extends Expression {
    left: TopExpression
    right: TopExpression
}

export const Assign = 'Assign';

export function isAssign(item: unknown): item is Assign {
    return reflection.isInstance(item, Assign);
}

export interface Comma extends Expression {
    left: Expression
    right: Expression
}

export const Comma = 'Comma';

export function isComma(item: unknown): item is Comma {
    return reflection.isInstance(item, Comma);
}

export interface Conditional extends Expression {
    condition: Expression
    else: Expression
    when: Expression
}

export const Conditional = 'Conditional';

export function isConditional(item: unknown): item is Conditional {
    return reflection.isInstance(item, Conditional);
}

export interface LiteralExpression extends Expression {
}

export const LiteralExpression = 'LiteralExpression';

export function isLiteralExpression(item: unknown): item is LiteralExpression {
    return reflection.isInstance(item, LiteralExpression);
}

export interface Logical_And extends Expression {
    left: Expression
    operator: Operator_And
    right: Expression
}

export const Logical_And = 'Logical_And';

export function isLogical_And(item: unknown): item is Logical_And {
    return reflection.isInstance(item, Logical_And);
}

export interface Logical_Or extends Expression {
    left: Expression
    operator: Operator_Or
    right: Expression
}

export const Logical_Or = 'Logical_Or';

export function isLogical_Or(item: unknown): item is Logical_Or {
    return reflection.isInstance(item, Logical_Or);
}

export interface Multiplication extends Expression {
    left: Expression
    operator: Operator_Multi
    right: Expression
}

export const Multiplication = 'Multiplication';

export function isMultiplication(item: unknown): item is Multiplication {
    return reflection.isInstance(item, Multiplication);
}

export interface NullishCoalescing extends Expression {
    left: Expression
    operator: Operator_NullishCoalescing
    right: Expression
}

export const NullishCoalescing = 'NullishCoalescing';

export function isNullishCoalescing(item: unknown): item is NullishCoalescing {
    return reflection.isInstance(item, NullishCoalescing);
}

export interface Power extends Expression {
    left: Expression
    operator: Operator_Power
    right: Expression
}

export const Power = 'Power';

export function isPower(item: unknown): item is Power {
    return reflection.isInstance(item, Power);
}

export interface RefExpression extends Expression {
    ref: Reference<Variable>
}

export const RefExpression = 'RefExpression';

export function isRefExpression(item: unknown): item is RefExpression {
    return reflection.isInstance(item, RefExpression);
}

export interface Relaction extends Expression {
    left: Expression
    operator: Operator_Relaction
    right: Expression
}

export const Relaction = 'Relaction';

export function isRelaction(item: unknown): item is Relaction {
    return reflection.isInstance(item, Relaction);
}

export interface BooleanLiteral extends LiteralExpression {
    value: BOOLEAN
}

export const BooleanLiteral = 'BooleanLiteral';

export function isBooleanLiteral(item: unknown): item is BooleanLiteral {
    return reflection.isInstance(item, BooleanLiteral);
}

export interface NumberLiteral extends LiteralExpression {
    percent: boolean
    value: number
}

export const NumberLiteral = 'NumberLiteral';

export function isNumberLiteral(item: unknown): item is NumberLiteral {
    return reflection.isInstance(item, NumberLiteral);
}

export interface PercentLiteral extends LiteralExpression, NumberLiteral {
}

export const PercentLiteral = 'PercentLiteral';

export function isPercentLiteral(item: unknown): item is PercentLiteral {
    return reflection.isInstance(item, PercentLiteral);
}

export interface StringLiteral extends LiteralExpression {
    value: string
}

export const StringLiteral = 'StringLiteral';

export function isStringLiteral(item: unknown): item is StringLiteral {
    return reflection.isInstance(item, StringLiteral);
}

export type Token_YAML = string

export type TextContnet = string

export type PlainTextContnet = string

export type CommonIndent = string

export type LabelContent = string

export type PlainText = string

export type RawText = string

export type RawTextPiece = string

export type TOKEN_AT = string

export type Token_Dot = string

export type Token_Logic = string

export type Token_Colon = string

export type Token_ListItem = string

export type Token_Bracket_L = string

export type Token_Bracket_R = string

export type Token_Template_L = string

export type Token_Template_R = string

export type Token_LabelStart = string

export type Escapse = string

export type Operator_Addition = string

export type Operator_Multi = string

export type VariableName = string

export type Operator_Variable_Prefix = '$' | '%'

export type BOOLEAN = 'true' | 'false'

export type Token_Paren_L = string

export type Token_Paren_R = string

export type Token_Comma = string

export type Operator_Equal = string

export type Operator_NullishCoalescing = string

export type Operator_And = string

export type Operator_Or = string

export type Operator_MoreThen = string

export type Operator_MoreThenEqual = string

export type Operator_LessThen = string

export type Operator_LessThenEqual = string

export type Operator_EqualEqual = string

export type Operator_Power = string

export type Operator_Division = string

export type Operator_Multiplication = string

export type Operator_Minus = string

export type Operator_Plus = string

export type Operator_Question = string

export type Operator_Colon = string

export type Operator_Relaction = string

export type Space = string

export type AdvScriptAstType = 'Block' | 'Call' | 'CharacterRef' | 'ConditionBlock' | 'Declare' | 'DeclareItem_Character' | 'DeclareItem_Macro' | 'DeclareKind' | 'DialogContent' | 'Document' | 'DocumentContents' | 'ElseIfStatement' | 'ElseStatement' | 'EndStatement' | 'ESCToken' | 'Identifier' | 'IfStatement' | 'InitialExpression' | 'List' | 'LogicBlock_ELSE' | 'LogicBlock_IF' | 'LogicBlock_IFELSE' | 'LogicStatment' | 'MacroParam' | 'Modifier' | 'ModifierList_Character' | 'ModifierList_Dialog' | 'ModifierList_Macro' | 'ModifierRef' | 'NameIdentifier' | 'Param' | 'ParamInitialExpression' | 'Pipe' | 'Plain' | 'PlainTextExpression' | 'QualifiedName' | 'Statment' | 'StoryBlock' | 'Template' | 'TitlePage' | 'TopExpression' | 'Variable' | 'VariableIdentifier' | 'YamlBlock' | 'AtInline' | 'CallMacro' | 'Label' | 'Mark' | 'CharactersDeclare' | 'MacroDeclare' | 'OtherDeclare' | 'Character' | 'Macro' | 'CharactersDeclareKind' | 'KeyedDeclareKind' | 'MacrosDeclareKind' | 'Content' | 'TextExpression' | 'VarStatement' | 'MacroPipe' | 'TextPipe' | 'Action' | 'Dialog' | 'Expression' | 'Addition' | 'Assign' | 'Comma' | 'Conditional' | 'LiteralExpression' | 'Logical_And' | 'Logical_Or' | 'Multiplication' | 'NullishCoalescing' | 'Power' | 'RefExpression' | 'Relaction' | 'BooleanLiteral' | 'NumberLiteral' | 'PercentLiteral' | 'StringLiteral';

export type AdvScriptAstReference = 'CharacterRef:ref' | 'MacroParam:ref' | 'ModifierRef:ref' | 'QualifiedName:name' | 'AtInline:ref' | 'CallMacro:ref' | 'MacroPipe:ref' | 'Dialog:ref' | 'RefExpression:ref';

export class AdvScriptAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['Block', 'Call', 'CharacterRef', 'ConditionBlock', 'Declare', 'DeclareItem_Character', 'DeclareItem_Macro', 'DeclareKind', 'DialogContent', 'Document', 'DocumentContents', 'ElseIfStatement', 'ElseStatement', 'EndStatement', 'ESCToken', 'Identifier', 'IfStatement', 'InitialExpression', 'List', 'LogicBlock_ELSE', 'LogicBlock_IF', 'LogicBlock_IFELSE', 'LogicStatment', 'MacroParam', 'Modifier', 'ModifierList_Character', 'ModifierList_Dialog', 'ModifierList_Macro', 'ModifierRef', 'NameIdentifier', 'Param', 'ParamInitialExpression', 'Pipe', 'Plain', 'PlainTextExpression', 'QualifiedName', 'Statment', 'StoryBlock', 'Template', 'TitlePage', 'TopExpression', 'Variable', 'VariableIdentifier', 'YamlBlock', 'AtInline', 'CallMacro', 'Label', 'Mark', 'CharactersDeclare', 'MacroDeclare', 'OtherDeclare', 'Character', 'Macro', 'CharactersDeclareKind', 'KeyedDeclareKind', 'MacrosDeclareKind', 'Content', 'TextExpression', 'VarStatement', 'MacroPipe', 'TextPipe', 'Action', 'Dialog', 'Expression', 'Addition', 'Assign', 'Comma', 'Conditional', 'LiteralExpression', 'Logical_And', 'Logical_Or', 'Multiplication', 'NullishCoalescing', 'Power', 'RefExpression', 'Relaction', 'BooleanLiteral', 'NumberLiteral', 'PercentLiteral', 'StringLiteral'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case YamlBlock: {
                return this.isSubtype(Block, supertype);
            }
            case AtInline:
            case CallMacro:
            case Label:
            case Mark: {
                return this.isSubtype(Call, supertype);
            }
            case CharactersDeclare:
            case MacroDeclare:
            case OtherDeclare: {
                return this.isSubtype(Declare, supertype);
            }
            case Character: {
                return this.isSubtype(DeclareItem_Character, supertype);
            }
            case Macro: {
                return this.isSubtype(DeclareItem_Macro, supertype);
            }
            case CharactersDeclareKind:
            case KeyedDeclareKind:
            case MacrosDeclareKind: {
                return this.isSubtype(DeclareKind, supertype);
            }
            case Content: {
                return this.isSubtype(DialogContent, supertype);
            }
            case TextExpression: {
                return this.isSubtype(ParamInitialExpression, supertype) || this.isSubtype(InitialExpression, supertype);
            }
            case VarStatement: {
                return this.isSubtype(LogicStatment, supertype);
            }
            case MacroPipe:
            case TextPipe: {
                return this.isSubtype(Pipe, supertype);
            }
            case Action:
            case Dialog: {
                return this.isSubtype(StoryBlock, supertype);
            }
            case Expression: {
                return this.isSubtype(TopExpression, supertype);
            }
            case Addition:
            case Assign:
            case Comma:
            case Conditional:
            case LiteralExpression:
            case Logical_And:
            case Logical_Or:
            case Multiplication:
            case NullishCoalescing:
            case Power:
            case RefExpression:
            case Relaction: {
                return this.isSubtype(Expression, supertype);
            }
            case BooleanLiteral:
            case NumberLiteral:
            case StringLiteral: {
                return this.isSubtype(LiteralExpression, supertype);
            }
            case PercentLiteral: {
                return this.isSubtype(LiteralExpression, supertype) || this.isSubtype(NumberLiteral, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(referenceId: AdvScriptAstReference): string {
        switch (referenceId) {
            case 'CharacterRef:ref': {
                return Character;
            }
            case 'MacroParam:ref': {
                return Param;
            }
            case 'ModifierRef:ref': {
                return Modifier;
            }
            case 'QualifiedName:name': {
                return Identifier;
            }
            case 'AtInline:ref': {
                return Character;
            }
            case 'CallMacro:ref': {
                return Macro;
            }
            case 'MacroPipe:ref': {
                return Macro;
            }
            case 'Dialog:ref': {
                return Character;
            }
            case 'RefExpression:ref': {
                return Variable;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
}

export const reflection = new AdvScriptAstReflection();
