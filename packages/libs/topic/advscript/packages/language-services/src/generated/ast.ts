/******************************************************************************
 * This file was generated by langium-cli 0.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, isAstNode } from 'langium';

export interface AtInline extends AstNode {
    readonly $container: Content;
    ref: Reference<Character>
}

export const AtInline = 'AtInline';

export function isAtInline(item: unknown): item is AtInline {
    return reflection.isInstance(item, AtInline);
}

export interface Call extends AstNode {
    readonly $container: Dialog | Content | Label;
    elements: Array<MacroParam>
    pipe: Pipe
    ref: Reference<Macro>
}

export const Call = 'Call';

export function isCall(item: unknown): item is Call {
    return reflection.isInstance(item, Call);
}

export interface Character extends AstNode {
    readonly $container: CharactersDeclare;
    elements: Array<Param>
    modifiers: Array<Modifier>
    name: NameIdentifier
}

export const Character = 'Character';

export function isCharacter(item: unknown): item is Character {
    return reflection.isInstance(item, Character);
}

export interface CharacterDeclareKind extends AstNode {
    readonly $container: CharactersDeclare;
    name: 'Characters'
}

export const CharacterDeclareKind = 'CharacterDeclareKind';

export function isCharacterDeclareKind(item: unknown): item is CharacterDeclareKind {
    return reflection.isInstance(item, CharacterDeclareKind);
}

export interface Content extends AstNode {
    readonly $container: StoryBlock;
    content: Array<AtInline | Template | Plain | Label | Call>
    pipe: Pipe
}

export const Content = 'Content';

export function isContent(item: unknown): item is Content {
    return reflection.isInstance(item, Content);
}

export interface Declare extends AstNode {
    readonly $container: TitlePage | YamlBlock;
}

export const Declare = 'Declare';

export function isDeclare(item: unknown): item is Declare {
    return reflection.isInstance(item, Declare);
}

export interface DeclareKind extends AstNode {
    readonly $container: OtherDeclare;
    name: PlainTextContnet
}

export const DeclareKind = 'DeclareKind';

export function isDeclareKind(item: unknown): item is DeclareKind {
    return reflection.isInstance(item, DeclareKind);
}

export interface DialogModifier extends AstNode {
    readonly $container: Dialog;
    ref: Reference<Modifier>
}

export const DialogModifier = 'DialogModifier';

export function isDialogModifier(item: unknown): item is DialogModifier {
    return reflection.isInstance(item, DialogModifier);
}

export interface Document extends AstNode {
    contents: Array<YamlBlock | LogicStatment | StoryBlock>
    header: TitlePage
}

export const Document = 'Document';

export function isDocument(item: unknown): item is Document {
    return reflection.isInstance(item, Document);
}

export interface Expression extends AstNode {
    readonly $container: Param | MacroParam | IfStatement | ElseIfStatement | Variable | Template | Comma | Assign | Relaction | Addition | Multiplication;
}

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export interface Identifier extends AstNode {
    readonly $container: Macro | Param;
    text: string
}

export const Identifier = 'Identifier';

export function isIdentifier(item: unknown): item is Identifier {
    return reflection.isInstance(item, Identifier);
}

export interface Label extends AstNode {
    readonly $container: Content;
    pipe: string | Call | LabelContent
    text: string
}

export const Label = 'Label';

export function isLabel(item: unknown): item is Label {
    return reflection.isInstance(item, Label);
}

export interface LogicStatment extends AstNode {
    readonly $container: Document;
}

export const LogicStatment = 'LogicStatment';

export function isLogicStatment(item: unknown): item is LogicStatment {
    return reflection.isInstance(item, LogicStatment);
}

export interface Macro extends AstNode {
    readonly $container: MacroDeclare;
    elements: Array<Param>
    groups: Array<Reference<NameIdentifier>>
    name: Identifier
}

export const Macro = 'Macro';

export function isMacro(item: unknown): item is Macro {
    return reflection.isInstance(item, Macro);
}

export interface MacroParam extends AstNode {
    readonly $container: Call | MacroPipe;
    ref: Reference<Param>
    value: TextExpression | Expression
}

export const MacroParam = 'MacroParam';

export function isMacroParam(item: unknown): item is MacroParam {
    return reflection.isInstance(item, MacroParam);
}

export interface MacrosDeclareKind extends AstNode {
    readonly $container: MacroDeclare;
    name: 'Macros'
}

export const MacrosDeclareKind = 'MacrosDeclareKind';

export function isMacrosDeclareKind(item: unknown): item is MacrosDeclareKind {
    return reflection.isInstance(item, MacrosDeclareKind);
}

export interface Modifier extends AstNode {
    readonly $container: Character;
    name: NameIdentifier
}

export const Modifier = 'Modifier';

export function isModifier(item: unknown): item is Modifier {
    return reflection.isInstance(item, Modifier);
}

export interface NameIdentifier extends AstNode {
    readonly $container: Character | Modifier;
    text: TextExpr
}

export const NameIdentifier = 'NameIdentifier';

export function isNameIdentifier(item: unknown): item is NameIdentifier {
    return reflection.isInstance(item, NameIdentifier);
}

export interface Param extends AstNode {
    readonly $container: Character | Macro;
    name: Identifier
    value: TextExpression | Expression
}

export const Param = 'Param';

export function isParam(item: unknown): item is Param {
    return reflection.isInstance(item, Param);
}

export interface Pipe extends AstNode {
    readonly $container: Content | Call | Template;
}

export const Pipe = 'Pipe';

export function isPipe(item: unknown): item is Pipe {
    return reflection.isInstance(item, Pipe);
}

export interface Plain extends AstNode {
    readonly $container: Content;
    content: PlainText
}

export const Plain = 'Plain';

export function isPlain(item: unknown): item is Plain {
    return reflection.isInstance(item, Plain);
}

export interface PlainTextExpression extends AstNode {
    readonly $container: OtherDeclare;
    value: PlainTextContnet
}

export const PlainTextExpression = 'PlainTextExpression';

export function isPlainTextExpression(item: unknown): item is PlainTextExpression {
    return reflection.isInstance(item, PlainTextExpression);
}

export interface QualifiedName extends AstNode {
    name: Array<Reference<Identifier>>
}

export const QualifiedName = 'QualifiedName';

export function isQualifiedName(item: unknown): item is QualifiedName {
    return reflection.isInstance(item, QualifiedName);
}

export interface StoryBlock extends AstNode {
    readonly $container: Document;
    contents: Array<Content>
}

export const StoryBlock = 'StoryBlock';

export function isStoryBlock(item: unknown): item is StoryBlock {
    return reflection.isInstance(item, StoryBlock);
}

export interface Template extends AstNode {
    readonly $container: Content;
    expression: Expression
    pipe: Pipe
}

export const Template = 'Template';

export function isTemplate(item: unknown): item is Template {
    return reflection.isInstance(item, Template);
}

export interface TextExpression extends AstNode {
    readonly $container: Param | MacroParam;
    value: TextContnet
}

export const TextExpression = 'TextExpression';

export function isTextExpression(item: unknown): item is TextExpression {
    return reflection.isInstance(item, TextExpression);
}

export interface TitlePage extends AstNode {
    readonly $container: Document;
    defines: Array<Declare>
    end: string
    start: string
}

export const TitlePage = 'TitlePage';

export function isTitlePage(item: unknown): item is TitlePage {
    return reflection.isInstance(item, TitlePage);
}

export interface Variable extends AstNode {
    readonly $container: VarStatement;
    initial: Expression
    name: VariableName
}

export const Variable = 'Variable';

export function isVariable(item: unknown): item is Variable {
    return reflection.isInstance(item, Variable);
}

export interface YamlBlock extends AstNode {
    readonly $container: Document;
    defines: Array<Declare>
    end: string
    start: string
}

export const YamlBlock = 'YamlBlock';

export function isYamlBlock(item: unknown): item is YamlBlock {
    return reflection.isInstance(item, YamlBlock);
}

export interface CharactersDeclare extends Declare {
    elements: Array<Character>
    kind: CharacterDeclareKind
}

export const CharactersDeclare = 'CharactersDeclare';

export function isCharactersDeclare(item: unknown): item is CharactersDeclare {
    return reflection.isInstance(item, CharactersDeclare);
}

export interface MacroDeclare extends Declare {
    elements: Array<Macro>
    kind: MacrosDeclareKind
}

export const MacroDeclare = 'MacroDeclare';

export function isMacroDeclare(item: unknown): item is MacroDeclare {
    return reflection.isInstance(item, MacroDeclare);
}

export interface OtherDeclare extends Declare {
    elements: PlainTextExpression
    kind: DeclareKind
}

export const OtherDeclare = 'OtherDeclare';

export function isOtherDeclare(item: unknown): item is OtherDeclare {
    return reflection.isInstance(item, OtherDeclare);
}

export interface Addition extends Expression {
    left: Expression
    operator: Token_Plus | Token_Minus
    right: Expression
}

export const Addition = 'Addition';

export function isAddition(item: unknown): item is Addition {
    return reflection.isInstance(item, Addition);
}

export interface Assign extends Expression {
    left: Expression
    right: Expression
}

export const Assign = 'Assign';

export function isAssign(item: unknown): item is Assign {
    return reflection.isInstance(item, Assign);
}

export interface Comma extends Expression {
    left: Expression
    operator: '??'
    right: Expression
}

export const Comma = 'Comma';

export function isComma(item: unknown): item is Comma {
    return reflection.isInstance(item, Comma);
}

export interface LiteralExpression extends Expression {
}

export const LiteralExpression = 'LiteralExpression';

export function isLiteralExpression(item: unknown): item is LiteralExpression {
    return reflection.isInstance(item, LiteralExpression);
}

export interface Multiplication extends Expression {
    left: Expression
    operator: '*' | '/'
    right: Expression
}

export const Multiplication = 'Multiplication';

export function isMultiplication(item: unknown): item is Multiplication {
    return reflection.isInstance(item, Multiplication);
}

export interface RefExpression extends Expression {
    ref: Reference<Variable>
}

export const RefExpression = 'RefExpression';

export function isRefExpression(item: unknown): item is RefExpression {
    return reflection.isInstance(item, RefExpression);
}

export interface Relaction extends Expression {
    left: Expression
    operator: '||' | '&&' | '>' | '<' | Token_EqualEqual | '<=' | '>='
    right: Expression
}

export const Relaction = 'Relaction';

export function isRelaction(item: unknown): item is Relaction {
    return reflection.isInstance(item, Relaction);
}

export interface ElseIfStatement extends LogicStatment {
    expression: Expression
    type: 'elseif'
}

export const ElseIfStatement = 'ElseIfStatement';

export function isElseIfStatement(item: unknown): item is ElseIfStatement {
    return reflection.isInstance(item, ElseIfStatement);
}

export interface ElseStatement extends LogicStatment {
    type: 'else'
}

export const ElseStatement = 'ElseStatement';

export function isElseStatement(item: unknown): item is ElseStatement {
    return reflection.isInstance(item, ElseStatement);
}

export interface EndStatement extends LogicStatment {
    type: 'end'
}

export const EndStatement = 'EndStatement';

export function isEndStatement(item: unknown): item is EndStatement {
    return reflection.isInstance(item, EndStatement);
}

export interface IfStatement extends LogicStatment {
    expression: Expression
    type: 'if'
}

export const IfStatement = 'IfStatement';

export function isIfStatement(item: unknown): item is IfStatement {
    return reflection.isInstance(item, IfStatement);
}

export interface VarStatement extends LogicStatment {
    expressions: Array<Variable>
    type: 'let'
}

export const VarStatement = 'VarStatement';

export function isVarStatement(item: unknown): item is VarStatement {
    return reflection.isInstance(item, VarStatement);
}

export interface MacroPipe extends Pipe {
    elements: Array<MacroParam>
    ref: Reference<Macro>
}

export const MacroPipe = 'MacroPipe';

export function isMacroPipe(item: unknown): item is MacroPipe {
    return reflection.isInstance(item, MacroPipe);
}

export interface TextPipe extends Pipe {
    text: LabelContent
}

export const TextPipe = 'TextPipe';

export function isTextPipe(item: unknown): item is TextPipe {
    return reflection.isInstance(item, TextPipe);
}

export interface Action extends StoryBlock {
}

export const Action = 'Action';

export function isAction(item: unknown): item is Action {
    return reflection.isInstance(item, Action);
}

export interface Dialog extends StoryBlock {
    elements: Array<DialogModifier | Call>
    ref: Reference<Character>
}

export const Dialog = 'Dialog';

export function isDialog(item: unknown): item is Dialog {
    return reflection.isInstance(item, Dialog);
}

export interface BooleanLiteral extends LiteralExpression {
    value: boolean
}

export const BooleanLiteral = 'BooleanLiteral';

export function isBooleanLiteral(item: unknown): item is BooleanLiteral {
    return reflection.isInstance(item, BooleanLiteral);
}

export interface NumberLiteral extends LiteralExpression {
    value: number
}

export const NumberLiteral = 'NumberLiteral';

export function isNumberLiteral(item: unknown): item is NumberLiteral {
    return reflection.isInstance(item, NumberLiteral);
}

export interface StringLiteral extends LiteralExpression {
    value: string
}

export const StringLiteral = 'StringLiteral';

export function isStringLiteral(item: unknown): item is StringLiteral {
    return reflection.isInstance(item, StringLiteral);
}

export type TextContnet = string

export type PlainTextContnet = string

export type VariableName = string

export type LabelContent = string

export type PlainText = string

export type Space = string

export type RawText = string

export type RawTextPiece = string

export type TOKEN_AT = string

export type Token_Equal = string

export type Token_EqualEqual = string

export type Token_Plus = string

export type Token_Minus = string

export type Token_Colon = string

export type Token_P = string

export type Token_Logic = string

export type Token_PL = string

export type Token_PR = string

export type Token_Comma = string

export type StringContent = string

export type Escapse = string

export type TextExpr = string

export type AdvscriptAstType = 'AtInline' | 'Call' | 'Character' | 'CharacterDeclareKind' | 'Content' | 'Declare' | 'DeclareKind' | 'DialogModifier' | 'Document' | 'Expression' | 'Identifier' | 'Label' | 'LogicStatment' | 'Macro' | 'MacroParam' | 'MacrosDeclareKind' | 'Modifier' | 'NameIdentifier' | 'Param' | 'Pipe' | 'Plain' | 'PlainTextExpression' | 'QualifiedName' | 'StoryBlock' | 'Template' | 'TextExpression' | 'TitlePage' | 'Variable' | 'YamlBlock' | 'CharactersDeclare' | 'MacroDeclare' | 'OtherDeclare' | 'Addition' | 'Assign' | 'Comma' | 'LiteralExpression' | 'Multiplication' | 'RefExpression' | 'Relaction' | 'ElseIfStatement' | 'ElseStatement' | 'EndStatement' | 'IfStatement' | 'VarStatement' | 'MacroPipe' | 'TextPipe' | 'Action' | 'Dialog' | 'BooleanLiteral' | 'NumberLiteral' | 'StringLiteral';

export type AdvscriptAstReference = 'AtInline:ref' | 'Call:ref' | 'DialogModifier:ref' | 'Macro:groups' | 'MacroParam:ref' | 'QualifiedName:name' | 'RefExpression:ref' | 'MacroPipe:ref' | 'Dialog:ref';

export class AdvscriptAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['AtInline', 'Call', 'Character', 'CharacterDeclareKind', 'Content', 'Declare', 'DeclareKind', 'DialogModifier', 'Document', 'Expression', 'Identifier', 'Label', 'LogicStatment', 'Macro', 'MacroParam', 'MacrosDeclareKind', 'Modifier', 'NameIdentifier', 'Param', 'Pipe', 'Plain', 'PlainTextExpression', 'QualifiedName', 'StoryBlock', 'Template', 'TextExpression', 'TitlePage', 'Variable', 'YamlBlock', 'CharactersDeclare', 'MacroDeclare', 'OtherDeclare', 'Addition', 'Assign', 'Comma', 'LiteralExpression', 'Multiplication', 'RefExpression', 'Relaction', 'ElseIfStatement', 'ElseStatement', 'EndStatement', 'IfStatement', 'VarStatement', 'MacroPipe', 'TextPipe', 'Action', 'Dialog', 'BooleanLiteral', 'NumberLiteral', 'StringLiteral'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case CharactersDeclare:
            case MacroDeclare:
            case OtherDeclare: {
                return this.isSubtype(Declare, supertype);
            }
            case Addition:
            case Assign:
            case Comma:
            case LiteralExpression:
            case Multiplication:
            case RefExpression:
            case Relaction: {
                return this.isSubtype(Expression, supertype);
            }
            case ElseIfStatement:
            case ElseStatement:
            case EndStatement:
            case IfStatement:
            case VarStatement: {
                return this.isSubtype(LogicStatment, supertype);
            }
            case MacroPipe:
            case TextPipe: {
                return this.isSubtype(Pipe, supertype);
            }
            case Action:
            case Dialog: {
                return this.isSubtype(StoryBlock, supertype);
            }
            case BooleanLiteral:
            case NumberLiteral:
            case StringLiteral: {
                return this.isSubtype(LiteralExpression, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(referenceId: AdvscriptAstReference): string {
        switch (referenceId) {
            case 'AtInline:ref': {
                return Character;
            }
            case 'Call:ref': {
                return Macro;
            }
            case 'DialogModifier:ref': {
                return Modifier;
            }
            case 'Macro:groups': {
                return NameIdentifier;
            }
            case 'MacroParam:ref': {
                return Param;
            }
            case 'QualifiedName:name': {
                return Identifier;
            }
            case 'RefExpression:ref': {
                return Variable;
            }
            case 'MacroPipe:ref': {
                return Macro;
            }
            case 'Dialog:ref': {
                return Character;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
}

export const reflection = new AdvscriptAstReflection();
