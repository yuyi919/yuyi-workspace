/******************************************************************************
 * This file was generated by langium-cli 0.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, isAstNode } from 'langium';

export interface Call extends AstNode {
    readonly $container: Dialog | Content | Label;
}

export const Call = 'Call';

export function isCall(item: unknown): item is Call {
    return reflection.isInstance(item, Call);
}

export interface Character extends AstNode {
    readonly $container: CharactersDeclare;
    elements: Array<Param>
    modifiers: Array<Modifier>
    name: NameIdentifier
}

export const Character = 'Character';

export function isCharacter(item: unknown): item is Character {
    return reflection.isInstance(item, Character);
}

export interface Content extends AstNode {
    readonly $container: StoryBlock;
    content: Array<Template | Label | Call | ESCToken | Plain>
    pipe: Pipe
}

export const Content = 'Content';

export function isContent(item: unknown): item is Content {
    return reflection.isInstance(item, Content);
}

export interface Declare extends AstNode {
    readonly $container: TitlePage | YamlBlock;
}

export const Declare = 'Declare';

export function isDeclare(item: unknown): item is Declare {
    return reflection.isInstance(item, Declare);
}

export interface DeclareKind extends AstNode {
    readonly $container: MacroDeclare | CharactersDeclare | OtherDeclare;
}

export const DeclareKind = 'DeclareKind';

export function isDeclareKind(item: unknown): item is DeclareKind {
    return reflection.isInstance(item, DeclareKind);
}

export interface DialogModifier extends AstNode {
    readonly $container: Dialog;
    ref: Reference<Modifier>
}

export const DialogModifier = 'DialogModifier';

export function isDialogModifier(item: unknown): item is DialogModifier {
    return reflection.isInstance(item, DialogModifier);
}

export interface Document extends AstNode {
    content: DocumentContents
    header: TitlePage
}

export const Document = 'Document';

export function isDocument(item: unknown): item is Document {
    return reflection.isInstance(item, Document);
}

export interface DocumentContents extends AstNode {
    readonly $container: Document;
    contents: Array<YamlBlock | LogicStatment | StoryBlock>
}

export const DocumentContents = 'DocumentContents';

export function isDocumentContents(item: unknown): item is DocumentContents {
    return reflection.isInstance(item, DocumentContents);
}

export interface ESCToken extends AstNode {
    readonly $container: Content;
    content: Token_Bracket_L
}

export const ESCToken = 'ESCToken';

export function isESCToken(item: unknown): item is ESCToken {
    return reflection.isInstance(item, ESCToken);
}

export interface Expression extends AstNode {
    readonly $container: Param | MacroParam | IfStatement | ElseIfStatement | Variable | Template | Comma | Assign | Relaction | Addition | Multiplication;
}

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export interface Identifier extends AstNode {
    readonly $container: Macro | Param;
    text: string
}

export const Identifier = 'Identifier';

export function isIdentifier(item: unknown): item is Identifier {
    return reflection.isInstance(item, Identifier);
}

export interface Label extends AstNode {
    readonly $container: Content;
    pipe: string | CallMacro | LabelContent
    text: string
}

export const Label = 'Label';

export function isLabel(item: unknown): item is Label {
    return reflection.isInstance(item, Label);
}

export interface LogicStatment extends AstNode {
    readonly $container: DocumentContents;
}

export const LogicStatment = 'LogicStatment';

export function isLogicStatment(item: unknown): item is LogicStatment {
    return reflection.isInstance(item, LogicStatment);
}

export interface Macro extends AstNode {
    readonly $container: MacroDeclare;
    elements: Array<Param>
    modifiers: Array<Reference<NameIdentifier>>
    name: Identifier
}

export const Macro = 'Macro';

export function isMacro(item: unknown): item is Macro {
    return reflection.isInstance(item, Macro);
}

export interface MacroParam extends AstNode {
    readonly $container: CallMacro | MacroPipe;
    ref: Reference<Param>
    value: TextExpression | Expression
}

export const MacroParam = 'MacroParam';

export function isMacroParam(item: unknown): item is MacroParam {
    return reflection.isInstance(item, MacroParam);
}

export interface Modifier extends AstNode {
    readonly $container: Character;
    name: NameIdentifier
}

export const Modifier = 'Modifier';

export function isModifier(item: unknown): item is Modifier {
    return reflection.isInstance(item, Modifier);
}

export interface NameIdentifier extends AstNode {
    readonly $container: Character | Modifier;
    text: TextExpr
}

export const NameIdentifier = 'NameIdentifier';

export function isNameIdentifier(item: unknown): item is NameIdentifier {
    return reflection.isInstance(item, NameIdentifier);
}

export interface Param extends AstNode {
    readonly $container: Character | Macro;
    name: Identifier
    value: TextExpression | Expression
}

export const Param = 'Param';

export function isParam(item: unknown): item is Param {
    return reflection.isInstance(item, Param);
}

export interface Pipe extends AstNode {
    readonly $container: Content | CallMacro | Template;
}

export const Pipe = 'Pipe';

export function isPipe(item: unknown): item is Pipe {
    return reflection.isInstance(item, Pipe);
}

export interface Plain extends AstNode {
    readonly $container: Content;
    content: PlainText
}

export const Plain = 'Plain';

export function isPlain(item: unknown): item is Plain {
    return reflection.isInstance(item, Plain);
}

export interface PlainTextExpression extends AstNode {
    readonly $container: OtherDeclare;
    value: PlainTextContnet
}

export const PlainTextExpression = 'PlainTextExpression';

export function isPlainTextExpression(item: unknown): item is PlainTextExpression {
    return reflection.isInstance(item, PlainTextExpression);
}

export interface QualifiedName extends AstNode {
    name: Array<Reference<Identifier>>
}

export const QualifiedName = 'QualifiedName';

export function isQualifiedName(item: unknown): item is QualifiedName {
    return reflection.isInstance(item, QualifiedName);
}

export interface StoryBlock extends AstNode {
    readonly $container: DocumentContents;
    contents: Array<Content>
}

export const StoryBlock = 'StoryBlock';

export function isStoryBlock(item: unknown): item is StoryBlock {
    return reflection.isInstance(item, StoryBlock);
}

export interface Template extends AstNode {
    readonly $container: Content;
    expression: Expression
    pipe: Pipe
}

export const Template = 'Template';

export function isTemplate(item: unknown): item is Template {
    return reflection.isInstance(item, Template);
}

export interface TextExpression extends AstNode {
    readonly $container: Param | MacroParam;
    value: TextContnet
}

export const TextExpression = 'TextExpression';

export function isTextExpression(item: unknown): item is TextExpression {
    return reflection.isInstance(item, TextExpression);
}

export interface TitlePage extends AstNode {
    readonly $container: Document;
    defines: Array<Declare>
    end: string
    start: string
}

export const TitlePage = 'TitlePage';

export function isTitlePage(item: unknown): item is TitlePage {
    return reflection.isInstance(item, TitlePage);
}

export interface Variable extends AstNode {
    readonly $container: VarStatement;
    initial: Expression
    name: VariableName
}

export const Variable = 'Variable';

export function isVariable(item: unknown): item is Variable {
    return reflection.isInstance(item, Variable);
}

export interface YamlBlock extends AstNode {
    readonly $container: DocumentContents;
    defines: Array<Declare>
    end: string
    start: string
}

export const YamlBlock = 'YamlBlock';

export function isYamlBlock(item: unknown): item is YamlBlock {
    return reflection.isInstance(item, YamlBlock);
}

export interface AtInline extends Call {
    isAt: boolean
    ref: Reference<Character>
}

export const AtInline = 'AtInline';

export function isAtInline(item: unknown): item is AtInline {
    return reflection.isInstance(item, AtInline);
}

export interface CallMacro extends Call {
    elements: Array<MacroParam>
    pipe: Pipe
    ref: Reference<Macro>
}

export const CallMacro = 'CallMacro';

export function isCallMacro(item: unknown): item is CallMacro {
    return reflection.isInstance(item, CallMacro);
}

export interface Mark extends Call {
    content: LabelContent
}

export const Mark = 'Mark';

export function isMark(item: unknown): item is Mark {
    return reflection.isInstance(item, Mark);
}

export interface CharactersDeclare extends Declare {
    elements: Array<Character>
    name: CharactersDeclareKind
}

export const CharactersDeclare = 'CharactersDeclare';

export function isCharactersDeclare(item: unknown): item is CharactersDeclare {
    return reflection.isInstance(item, CharactersDeclare);
}

export interface MacroDeclare extends Declare {
    elements: Array<Macro>
    name: MacrosDeclareKind
}

export const MacroDeclare = 'MacroDeclare';

export function isMacroDeclare(item: unknown): item is MacroDeclare {
    return reflection.isInstance(item, MacroDeclare);
}

export interface OtherDeclare extends Declare {
    elements: PlainTextExpression
    name: KeyedDeclareKind
}

export const OtherDeclare = 'OtherDeclare';

export function isOtherDeclare(item: unknown): item is OtherDeclare {
    return reflection.isInstance(item, OtherDeclare);
}

export interface CharactersDeclareKind extends DeclareKind {
    text: 'Characters'
}

export const CharactersDeclareKind = 'CharactersDeclareKind';

export function isCharactersDeclareKind(item: unknown): item is CharactersDeclareKind {
    return reflection.isInstance(item, CharactersDeclareKind);
}

export interface KeyedDeclareKind extends DeclareKind {
    text: PlainTextContnet
}

export const KeyedDeclareKind = 'KeyedDeclareKind';

export function isKeyedDeclareKind(item: unknown): item is KeyedDeclareKind {
    return reflection.isInstance(item, KeyedDeclareKind);
}

export interface MacrosDeclareKind extends DeclareKind {
    text: 'Macros'
}

export const MacrosDeclareKind = 'MacrosDeclareKind';

export function isMacrosDeclareKind(item: unknown): item is MacrosDeclareKind {
    return reflection.isInstance(item, MacrosDeclareKind);
}

export interface Addition extends Expression {
    left: Expression
    operator: Operator_Plus | Operator_Minus
    right: Expression
}

export const Addition = 'Addition';

export function isAddition(item: unknown): item is Addition {
    return reflection.isInstance(item, Addition);
}

export interface Assign extends Expression {
    left: Expression
    right: Expression
}

export const Assign = 'Assign';

export function isAssign(item: unknown): item is Assign {
    return reflection.isInstance(item, Assign);
}

export interface Comma extends Expression {
    left: Expression
    operator: Operator_QuestionQuestion
    right: Expression
}

export const Comma = 'Comma';

export function isComma(item: unknown): item is Comma {
    return reflection.isInstance(item, Comma);
}

export interface LiteralExpression extends Expression {
}

export const LiteralExpression = 'LiteralExpression';

export function isLiteralExpression(item: unknown): item is LiteralExpression {
    return reflection.isInstance(item, LiteralExpression);
}

export interface Multiplication extends Expression {
    left: Expression
    operator: Operator_Multiplication | Operator_Division
    right: Expression
}

export const Multiplication = 'Multiplication';

export function isMultiplication(item: unknown): item is Multiplication {
    return reflection.isInstance(item, Multiplication);
}

export interface RefExpression extends Expression {
    ref: Reference<Variable>
}

export const RefExpression = 'RefExpression';

export function isRefExpression(item: unknown): item is RefExpression {
    return reflection.isInstance(item, RefExpression);
}

export interface Relaction extends Expression {
    left: Expression
    operator: Operator_And | Operator_Or | Operator_Relaction
    right: Expression
}

export const Relaction = 'Relaction';

export function isRelaction(item: unknown): item is Relaction {
    return reflection.isInstance(item, Relaction);
}

export interface ElseIfStatement extends LogicStatment {
    expression: Expression
    kind: 'elseif'
}

export const ElseIfStatement = 'ElseIfStatement';

export function isElseIfStatement(item: unknown): item is ElseIfStatement {
    return reflection.isInstance(item, ElseIfStatement);
}

export interface ElseStatement extends LogicStatment {
    kind: 'else'
}

export const ElseStatement = 'ElseStatement';

export function isElseStatement(item: unknown): item is ElseStatement {
    return reflection.isInstance(item, ElseStatement);
}

export interface EndStatement extends LogicStatment {
    kind: 'end'
}

export const EndStatement = 'EndStatement';

export function isEndStatement(item: unknown): item is EndStatement {
    return reflection.isInstance(item, EndStatement);
}

export interface IfStatement extends LogicStatment {
    expression: Expression
    kind: 'if'
}

export const IfStatement = 'IfStatement';

export function isIfStatement(item: unknown): item is IfStatement {
    return reflection.isInstance(item, IfStatement);
}

export interface VarStatement extends LogicStatment {
    expressions: Array<Variable>
    kind: 'let'
}

export const VarStatement = 'VarStatement';

export function isVarStatement(item: unknown): item is VarStatement {
    return reflection.isInstance(item, VarStatement);
}

export interface MacroPipe extends Pipe {
    elements: Array<MacroParam>
    ref?: Reference<Macro>
}

export const MacroPipe = 'MacroPipe';

export function isMacroPipe(item: unknown): item is MacroPipe {
    return reflection.isInstance(item, MacroPipe);
}

export interface TextPipe extends Pipe {
    text: LabelContent
}

export const TextPipe = 'TextPipe';

export function isTextPipe(item: unknown): item is TextPipe {
    return reflection.isInstance(item, TextPipe);
}

export interface Action extends StoryBlock {
}

export const Action = 'Action';

export function isAction(item: unknown): item is Action {
    return reflection.isInstance(item, Action);
}

export interface Dialog extends StoryBlock {
    elements: Array<DialogModifier | Call>
    name: Reference<Character>
}

export const Dialog = 'Dialog';

export function isDialog(item: unknown): item is Dialog {
    return reflection.isInstance(item, Dialog);
}

export interface BooleanLiteral extends LiteralExpression {
    value: boolean
}

export const BooleanLiteral = 'BooleanLiteral';

export function isBooleanLiteral(item: unknown): item is BooleanLiteral {
    return reflection.isInstance(item, BooleanLiteral);
}

export interface NumberLiteral extends LiteralExpression {
    value: number
}

export const NumberLiteral = 'NumberLiteral';

export function isNumberLiteral(item: unknown): item is NumberLiteral {
    return reflection.isInstance(item, NumberLiteral);
}

export interface StringLiteral extends LiteralExpression {
    value: string
}

export const StringLiteral = 'StringLiteral';

export function isStringLiteral(item: unknown): item is StringLiteral {
    return reflection.isInstance(item, StringLiteral);
}

export type TextContnet = string

export type PlainTextContnet = string

export type VariableName = string

export type LabelContent = string

export type PlainText = string

export type Space = string

export type RawText = string

export type RawTextPiece = string

export type TOKEN_AT = string

export type Token_P = string

export type Token_Logic = string

export type Token_Colon = string

export type Token_ListItem = string

export type Token_Paren_L = string

export type Token_Paren_R = string

export type Token_Bracket_L = string

export type Token_Bracket_R = string

export type Token_Template_L = string

export type Token_Template_R = string

export type Token_Comma = string

export type Operator_Equal = string

export type Operator_QuestionQuestion = string

export type Operator_And = string

export type Operator_Or = string

export type Operator_MoreThen = string

export type Operator_MoreThenEqual = string

export type Operator_LessThen = string

export type Operator_LessThenEqual = string

export type Operator_EqualEqual = string

export type Operator_Division = string

export type Operator_Multiplication = string

export type Operator_Minus = string

export type Operator_Plus = string

export type Operator_Relaction = string

export type StringContent = string

export type Escapse = string

export type TextExpr = string

export type AdvscriptAstType = 'Call' | 'Character' | 'Content' | 'Declare' | 'DeclareKind' | 'DialogModifier' | 'Document' | 'DocumentContents' | 'ESCToken' | 'Expression' | 'Identifier' | 'Label' | 'LogicStatment' | 'Macro' | 'MacroParam' | 'Modifier' | 'NameIdentifier' | 'Param' | 'Pipe' | 'Plain' | 'PlainTextExpression' | 'QualifiedName' | 'StoryBlock' | 'Template' | 'TextExpression' | 'TitlePage' | 'Variable' | 'YamlBlock' | 'AtInline' | 'CallMacro' | 'Mark' | 'CharactersDeclare' | 'MacroDeclare' | 'OtherDeclare' | 'CharactersDeclareKind' | 'KeyedDeclareKind' | 'MacrosDeclareKind' | 'Addition' | 'Assign' | 'Comma' | 'LiteralExpression' | 'Multiplication' | 'RefExpression' | 'Relaction' | 'ElseIfStatement' | 'ElseStatement' | 'EndStatement' | 'IfStatement' | 'VarStatement' | 'MacroPipe' | 'TextPipe' | 'Action' | 'Dialog' | 'BooleanLiteral' | 'NumberLiteral' | 'StringLiteral';

export type AdvscriptAstReference = 'DialogModifier:ref' | 'Macro:modifiers' | 'MacroParam:ref' | 'QualifiedName:name' | 'AtInline:ref' | 'CallMacro:ref' | 'RefExpression:ref' | 'MacroPipe:ref' | 'Dialog:name';

export class AdvscriptAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['Call', 'Character', 'Content', 'Declare', 'DeclareKind', 'DialogModifier', 'Document', 'DocumentContents', 'ESCToken', 'Expression', 'Identifier', 'Label', 'LogicStatment', 'Macro', 'MacroParam', 'Modifier', 'NameIdentifier', 'Param', 'Pipe', 'Plain', 'PlainTextExpression', 'QualifiedName', 'StoryBlock', 'Template', 'TextExpression', 'TitlePage', 'Variable', 'YamlBlock', 'AtInline', 'CallMacro', 'Mark', 'CharactersDeclare', 'MacroDeclare', 'OtherDeclare', 'CharactersDeclareKind', 'KeyedDeclareKind', 'MacrosDeclareKind', 'Addition', 'Assign', 'Comma', 'LiteralExpression', 'Multiplication', 'RefExpression', 'Relaction', 'ElseIfStatement', 'ElseStatement', 'EndStatement', 'IfStatement', 'VarStatement', 'MacroPipe', 'TextPipe', 'Action', 'Dialog', 'BooleanLiteral', 'NumberLiteral', 'StringLiteral'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case AtInline:
            case CallMacro:
            case Mark: {
                return this.isSubtype(Call, supertype);
            }
            case CharactersDeclare:
            case MacroDeclare:
            case OtherDeclare: {
                return this.isSubtype(Declare, supertype);
            }
            case CharactersDeclareKind:
            case KeyedDeclareKind:
            case MacrosDeclareKind: {
                return this.isSubtype(DeclareKind, supertype);
            }
            case Addition:
            case Assign:
            case Comma:
            case LiteralExpression:
            case Multiplication:
            case RefExpression:
            case Relaction: {
                return this.isSubtype(Expression, supertype);
            }
            case ElseIfStatement:
            case ElseStatement:
            case EndStatement:
            case IfStatement:
            case VarStatement: {
                return this.isSubtype(LogicStatment, supertype);
            }
            case MacroPipe:
            case TextPipe: {
                return this.isSubtype(Pipe, supertype);
            }
            case Action:
            case Dialog: {
                return this.isSubtype(StoryBlock, supertype);
            }
            case BooleanLiteral:
            case NumberLiteral:
            case StringLiteral: {
                return this.isSubtype(LiteralExpression, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(referenceId: AdvscriptAstReference): string {
        switch (referenceId) {
            case 'DialogModifier:ref': {
                return Modifier;
            }
            case 'Macro:modifiers': {
                return NameIdentifier;
            }
            case 'MacroParam:ref': {
                return Param;
            }
            case 'QualifiedName:name': {
                return Identifier;
            }
            case 'AtInline:ref': {
                return Character;
            }
            case 'CallMacro:ref': {
                return Macro;
            }
            case 'RefExpression:ref': {
                return Variable;
            }
            case 'MacroPipe:ref': {
                return Macro;
            }
            case 'Dialog:name': {
                return Character;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
}

export const reflection = new AdvscriptAstReflection();
